---
title: 二分搜索入门
published: 2024-1
description: ''
image: ''
tags: [二分搜索]
category: ''
draft: false 
lang: 'zh_CN'
---


:::note 介绍
本篇是二分搜索入门篇。
二分搜索并不只是在有序数组中搜索， 不仅是对细节的处理， 以及对算法的理解， Coding的掌握。
二分搜索是典型的$O(logn)$的算法， 一般面试或者题目要求对数时间几乎都联系二分搜索。
不应该只掌握初学时的二分查找数的方法是远远不够的。
:::

#### 有序数组中搜索特定值
[二分查找](https://leetcode.cn/problems/binary-search/description/)
```java
class Solution {
    public int search(int[] nums, int target) {
        int ans = -1;//初始化下标-1, 如果target不在数组里则默认返回-1
        if(nums == null || nums.length < 1){
            return ans;
        }

        //初始化处理: l,r,m
        int l = 0,r = nums.length-1, m = 0;
        while(l <= r){
            //这种位运算求中点是经典写法， 可以有效防止溢出
            m = l + ((r - l) >> 1);
            if(nums[m] == target){
                ans = m;
                break;
            }
            else if(nums[m] < target){
                l = m + 1;
            }
            else{
                //nums[m] > target
                r = m - 1;
            }
        }
        return ans;
    }
}

```


#### 有序数组中的范围边界一
[搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

本题的思路是， 找到第一个大于等于target的下标， 如果没有则返回数组长度。
>输入: nums = [1,3,5,6], target = 5
>输出: 2
**二分搜索不一定查找具体的数值， 也可以查找边界。**
通过二分查找查找在有序数组中>=5的最左边界的那个位置就是最佳位置。
```java
class Solution {
    //保证nums有序， 才可使用二分搜索
    //查找有序数组中>=nums的最靠左边界
    public int searchInsert(int[] nums, int target) {
        if(nums == null || nums.length < 1){
            return -1;
        }
        int l = 0, r = nums.length-1, m = 0;
        int ans = r+1;//初始化为有序数组的长度， 如果target比整个数组都大时就在此位置插入
        while(l <= r){
            m = l + ((r - l) >> 1);
            if(nums[m] >= target){
                //找到一个边界m， 但不一定是紧确的边界
                ans = m;
                //放缩右区间， 前往左部分做更精确的放缩。
                r = m - 1;
            }
            else{
                l = m + 1;
            }
        }
        return ans;
    }
}
```


#### 有序数组中的范围边界二
查找有序数组中<=`target`的最右边界。

以下解法是保证[搜索插入位置](https://leetcode.cn/problems/search-insert-position/)能通过的写法。
下面左边界的最右和上面右边界的最左完全对称的写法。这里纯粹是保证通过的写法。
```java
class Solution {
    //保证nums有序， 才可使用二分搜索
    //查找有序数组中<=nums的最右边界
    public int searchInsert(int[] nums, int target) {
        if(nums == null || nums.length < 1){
            return -1;
        }
        int l = 0, r = nums.length-1, m = 0;
        while(l <= r){
            m = l + ((r - l) >> 1);
            if(nums[m] < target){
                //放缩左区间， 前往右部分做更精确的放缩。
                l = m + 1;
            }
            else{
                r = m - 1;
            }
        }
        return l;
    }
}
```


#### 寻找峰值
