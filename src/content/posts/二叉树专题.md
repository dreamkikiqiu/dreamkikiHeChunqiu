---
title: äºŒå‰æ ‘ä¸“é¢˜
published: 2024-10-25
description: 'äºŒå‰æ ‘ä¸“é¢˜-ä¸åŒ…å«æ ‘å½¢dp'
image: './guide/bst.jpg'
tags: [äºŒå‰æ ‘]
category: 'ç®—æ³•ä¸é«˜çº§è®¾è®¡æŠ€å·§(è¿›é˜¶ç¯‡)'
draft: false 
lang: 'zh_CN'
---

:::note[é˜…è¯»è¯´æ˜(å¿…çœ‹)]
æœ¬ç¯‡äºŒå‰æ ‘ä¸“é¢˜ï¼Œè¯»è€…åº”è¯¥å…·å¤‡ä¸€å®šçš„æ•°æ®ç»“æ„å’Œç®—æ³•èƒ½åŠ›ã€‚
>1. `åˆ·é¢˜ç½‘ç«™:æ´›è°·ï¼Œleetcode, ç‰›å®¢ç½‘ `ã€‚ ç½‘ç«™é“¾æ¥è‡ªå¯»ï¼
>2. `å‚è€ƒ: ã€Šç¨‹åºå‘˜ä»£ç é¢è¯•æŒ‡å—ã€‹ & ä»£ç éšæƒ³å½•ã€‚ æ¯é“é¢˜åæˆ‘éƒ½ä¼šé™„å¸¦é“¾æ¥ï¼Œ ä»£ç ä¼šä¸Šä¼ åˆ°GitHubä¸Š`
>3. åŸºç¡€éƒ¨åˆ†ç®€ç•¥(ä»»æ„æ•™æéƒ½èƒ½æ‰¾åˆ°çš„å†…å®¹ï¼Œ åˆå­¦è€…éƒ½ä¼šçš„å†…å®¹); è¿›é˜¶éƒ¨åˆ†æœ‰ä¸€å®šæ€è€ƒéš¾åº¦å’ŒcodingæŒ‘æˆ˜;æ‹“å±•éƒ¨åˆ†å­¦å¾—æ›´åŠ æœ‰æ·±åº¦ã€‚ ä¸Šéš¾åº¦çš„å¹³è¡¡æ ‘æœ‰åºè¡¨(treap, spaly, çº¢é»‘æ ‘è¿™äº›)åŸºæœ¬ä¸ä¼šæ¶‰åŠã€‚
>4. ç¼–ç¨‹è¯­è¨€: ç¬”è€…çƒ­çˆ±**Java**, ä¸»è¦ä»¥Javaè¯­è¨€ä¸ºä¸»ã€‚ å¯¹äºæŸäº›æƒ…å†µä¸‹ï¼ˆé€’å½’ææ„ï¼‰ä¼šå°è¯•æä¾›C++ä»£ç ã€‚---å€ŸåŠ©**chatgpt**è½¬æ¢æˆè‡ªå·±çš„è¯­è¨€å§ï¼
>5. **IDEï¼šIntellij IDEAã€‚ ä¸»é¢˜: MonoKai pro ; å­—ä½“: Fira cod lightã€‚** Codingå¾ˆèˆ’æœ---è‡ªè¡Œå®‰è£…ç›¸å…³æ’ä»¶
>6. å®¹å™¨å’Œç®—æ³•æŠ€å·§: æ ˆï¼Œ é˜Ÿåˆ—ï¼Œ å“ˆå¸Œè¡¨ï¼Œ æ•°ç»„ï¼› é€’å½’ï¼Œ åˆ†æ²»ï¼Œ å¯¹äºéƒ¨åˆ†å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„é¢˜ä¹Ÿä¼šæä¾›è§£é‡Šã€‚ è¯»è€…åº”å½“å¯ä»¥ç”¨æ•°ç»„æ‰‹æ“æ ˆå’Œé˜Ÿåˆ—ç»“æ„
>7. ç›®å‰è¯»è¿‡çš„æ•°æ®ç»“æ„å’Œç®—æ³•ä¹¦ç±ï¼šã€Šå¤§è¯æ•°æ®ç»“æ„ï¼ˆCè¯­è¨€ï¼‰ã€‹ï¼Œã€Šæ•°æ®ç»“æ„å’Œç®—æ³•åˆ†æï¼ˆJavaè¯­è¨€æè¿°ï¼‰ã€‹ï¼Œã€Šç®—æ³•å¯¼è®ºã€‹ï¼Œ ã€Šç¨‹åºå‘˜ä»£ç é¢è¯•æŒ‡å—ã€‹ã€‚
>8. æ©å¸ˆ:å·¦ç¨‹äº‘ã€‚ä¸‹é¢é¢˜ç›®é‡åˆ°ä»»ä½•çš„é—®é¢˜éƒ½å¯ä»¥è§‚çœ‹å¶åƒçš„è§†é¢‘è®²è§£è§£å†³-è‡ªè¡Œæœç´¢å¯¹åº”è§†é¢‘:[è¯¾ç¨‹é“¾æ¥å’Œä»£ç ä»“åº“<-](https://dreamkikiqiu.github.io/dreamkikiqiu/about/)
:::

:::tip[æç¤º]
- é¢˜ç›®é€šè¿‡000~999è¿›è¡Œç¼–å·ï¼Œ ä¸è¿‡ç½‘ç«™æš‚æœªæä¾›ç›®å½•ç»“æ„æ— æ³•å¿«é€Ÿå¯»æ‰¾ç›¸å…³é¢˜ç›®ï¼ˆä¸å¥½æ„æ€ï¼‰ğŸ¥²ã€‚
- æ ‡é¢˜å¯ä»¥ç‚¹å‡»è·³è½¬é¡µé¢ã€‚æ¯é“é¢˜éƒ½é…æœ‰ç›¸å…³é“¾æ¥ã€‚ å‡½æ•°é¢˜ä¸€èˆ¬æ˜¯leetcode, acmé£æ ¼æ˜¯ç‰›å®¢å’Œæ´›è°·çš„ã€‚ å¤„ç†è¾“å…¥è¾“å‡ºçš„é¢˜çš„ç±»é‡Œå¤šæ•°æœ‰mainå‡½æ•°å¯ä»¥è‡ªè¡Œè¿è¡Œæµ‹è¯•ã€‚
- æ¯é“é¢˜éƒ½å¯ä»¥ctrl + c, ctrl + væäº¤ã€‚**æ³¨æ„:ä¿®æ”¹ç±»åï¼Œ å‡½æ•°åï¼Œ ä¸è¦æäº¤æ— å…³çš„ç±»ã€‚**
- æ€è€ƒå’Œcoding, è€Œä¸æ˜¯æ³¨é‡é¢˜é‡å’Œé€Ÿåº¦å“¦ã€‚ğŸ˜˜
:::


:::note[Class01éå†]

#### **Coding[åŸºç¡€]åŠ›æ‰£ç»å…¸ä¸‰é—®:é€’å½’ä»¥åŠéé€’å½’ç‰ˆæœ¬ä¸‰åºéå†**

##### **001 [å…ˆåºéå†-é€’å½’ç‰ˆ](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)**
**åŸºç¡€å›é¡¾: å…ˆåºéå†ï¼ˆå‰åºéå†ï¼‰: å¯¹äºæ ‘åŠå…¶å­æ ‘å§‹ç»ˆéµå¾ª æ ¹ > å·¦ > å³çš„ä¼˜å…ˆçº§é¡ºåºã€‚** 
```java
    //è¾…åŠ©preorderTraversalRecçš„æ–¹æ³•
    private void f(TreeNode head, List<Integer> list){
        if(head != null){
            list.add(head.val);
            f(head.left, list);
            f(head.right, list);
        }
    }
    //ä¸»æ–¹æ³•, ä¿®æ”¹å‡½æ•°å->preorderTraversal
    public List<Integer> preorderTraversal(TreeNode head){
        List<Integer> list = new ArrayList<>();
        f(head, list);
        return list;
    }
```
-----
ä»é€’å½’æ¥çœ‹ï¼Œ è¿™é“é¢˜å¯ä»¥ç†è§£ä¸º**æ ¹èŠ‚ç‚¹ + å·¦å­æ ‘å…ˆåºç”Ÿæˆçš„åˆ—è¡¨ + å³å­æ ‘å…ˆåºç”Ÿæˆçš„åˆ—è¡¨**ã€‚ äºæ˜¯æœ‰äº†ç¬¬äºŒç§æ›´å¥½çœ‹çš„é€’å½’å†™æ³•ã€‚
ç”±äºè¿™é‡Œåˆ—è¡¨ç›¸åŠ ï¼Œ Javaä¸­è°ƒç”¨äº†`addAll`æ–¹æ³•ã€‚
```java
    /**
     * ä¿®æ”¹å‡½æ•°å->preorderTraversal
     * ç”±äºé€’å½’ï¼Œå‡½æ•°ä½“å†…éƒ¨ä»£ç ä¹Ÿè¦è°ƒæ•´ã€‚
     */
    public List<Integer> preorderTraversalRec1(TreeNode head){
        List<Integer> list = new ArrayList<>();
        if(head != null) {
            list.add(head.val);
            list.addAll(preorderTraversalRec1(head.left));
            list.addAll(preorderTraversalRec1(head.right));
        }
        return list;
    }
```

##### **002 [ä¸­åºéå†-é€’å½’ç‰ˆ](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)**
**åŸºç¡€å›é¡¾: ä¸­åºéå†: å¯¹äºæ ‘åŠå…¶å­æ ‘å§‹ç»ˆéµå¾ª å·¦> æ ¹ > å³çš„ä¼˜å…ˆçº§é¡ºåºã€‚** 

```java
    //è¾…åŠ©inorderTraversalRecçš„æ–¹æ³•
    private void f2(TreeNode head, List<Integer> list){
        if(head != null){
            f2(head.left, list);
            list.add(head.val);
            f2(head.right, list);
        }
    }
    //ä¸»æ–¹æ³•  ä¿®æ”¹å‡½æ•°å->inorderTraversal
    public List<Integer> inorderTraversalRec(TreeNode head){
        List<Integer> list = new ArrayList<>();
        f2(head, list);
        return list;
    }
```
-----------------
ä»é€’å½’æ¥çœ‹ï¼Œ è¿™é“é¢˜å¯ä»¥ç†è§£ä¸º**å·¦å­æ ‘å…ˆåºç”Ÿæˆçš„åˆ—è¡¨+ æ ¹èŠ‚ç‚¹ + å³å­æ ‘å…ˆåºç”Ÿæˆçš„åˆ—è¡¨**ï¼Œ åŒå…ˆåºéå†èµ·ä»…ä»…æŒªåŠ¨ä¸€ä¸‹ä½ç½®ã€‚
```java
    /**
     * ä¿®æ”¹å‡½æ•°å->inorderTraversal
     * ç”±äºé€’å½’ï¼Œå‡½æ•°ä½“å†…éƒ¨ä»£ç ä¹Ÿè¦è°ƒæ•´ã€‚
     */
    public List<Integer> inorderTraversalRec1(TreeNode head){
        List<Integer> list = new ArrayList<>();
        if(head != null) {
            list.addAll(inorderTraversalRec1(head.left));
            list.add(head.val);
            list.addAll(inorderTraversalRec1(head.right));
        }
        return list;
    }
```

##### **003 [ååºéå†-é€’å½’ç‰ˆ](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)**
**åŸºç¡€å›é¡¾: ååºéå†: å¯¹äºæ ‘åŠå…¶å­æ ‘å§‹ç»ˆéµå¾ª å·¦> å³ >æ ¹çš„ä¼˜å…ˆçº§é¡ºåºã€‚** 
```java
    //è¾…åŠ©æ–¹æ³•
    private void f3(TreeNode head, List<Integer> list){
        if(head != null){
            f3(head.left, list);
            f3(head.right, list);
            list.add(head.val);
        }
    }
    //ä¸»æ–¹æ³•  ä¿®æ”¹å‡½æ•°å->postorderTraversal
    public List<Integer> postorderTraversalRec(TreeNode head){
        List<Integer> list = new ArrayList<>();
        f3(head, list);
        return list;
    }
```
----------------------------
æ€æƒ³ä¸ä¸Šè¿°ä¸€è‡´ï¼Œ åªæ˜¯æ”¹å˜ä¸€ä¸‹é¡ºåºã€‚
```java
    /**
     * ä¿®æ”¹å‡½æ•°å->postorderTraversal
     * ç”±äºé€’å½’ï¼Œå‡½æ•°ä½“å†…éƒ¨ä»£ç ä¹Ÿè¦è°ƒæ•´ã€‚
     */
    public List<Integer> postorderTraversalRec1(TreeNode head){
        List<Integer> list = new ArrayList<>();
        if(head != null){
            list.addAll(postorderTraversalRec1(head.left));
            list.addAll(postorderTraversalRec1(head.right));
            list.add(head.val);
        }
        return list;
    }
```

##### 004 [å…ˆåºéå†-éé€’å½’](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
æ‰€æœ‰é€’å½’çš„æ–¹æ³•éƒ½å¯ä»¥æ”¹æˆè¿­ä»£çš„å½¢å¼ï¼Œ åŒºåˆ«åœ¨äºé€’å½’æ˜¯é€šè¿‡ç³»ç»Ÿæ ˆçš„æ–¹å¼ï¼Œ ç³»ç»Ÿæ ˆä¸­å­˜å‚¨ä¿¡æ¯ã€‚ è€Œè¿­ä»£æ˜¯é€šè¿‡æˆ‘ä»¬æ‰‹åŠ¨å‹æ ˆçš„æ–¹å¼ï¼Œ ä¸€èˆ¬çš„é€’å½’æ–¹æ³•éƒ½å¯ä»¥ç”¨æ ˆå¾ˆå¥½æ¨¡æ‹Ÿå®ç°ï¼Œ å› ä¸ºæœ¬è´¨æ˜¯ä¸€å›äº‹ï¼Œ ä¸è¿‡å‡½æ•°æ ˆéšè—äº†ç»†èŠ‚ï¼Œ ä¸€èˆ¬æ¥è¯´é€’å½’æ›´åŠ ç›´ç™½æ˜“æ‡‚ï¼Œ è€Œæ ˆæ¨¡æ‹Ÿçš„è¿­ä»£æ–¹å¼æœ‰ç‚¹"æ¶å¿ƒ"äº†ã€‚

å…ˆåºçš„å¤„ç†æ–¹å¼: 
1. å¤„ç†æ ¹èŠ‚ç‚¹ã€‚
2. å°½å¯èƒ½æ·±çš„å¤„ç†å·¦å­æ ‘ã€‚
3. å·¦å­æ ‘å¿…é¡»å¤„ç†å®Œåï¼Œ å†ç»§ç»­å¤„ç†å³å­æ ‘ã€‚
4. ä»¥ä¸Šè§„åˆ™é€‚ç”¨ä»»æ„æ•´æ£µæ ‘åŠå…¶å­æ ‘ã€‚

ç®—æ³•æµç¨‹:
1. ç”³è¯·ä¸€ä¸ªæ ˆ(Javaå†…ç½®æ ˆæˆ–è€…å…¨å±€é™æ€æ•°ç»„æ‰‹å†™æ ˆ)ï¼Œ å°†å½“å‰æ ‘çš„æ ¹èŠ‚ç‚¹å‹å…¥æ ˆä¸­ã€‚
2. ç„¶åå¼¹æ ˆå°†å¼¹å‡ºèŠ‚ç‚¹ä¿å­˜åœ¨å˜é‡curä¸­ï¼Œ**å¤„ç†èŠ‚ç‚¹cur**ã€‚ **å…ˆå‹å³å­æ ‘å†å‹å·¦å­æ ‘ï¼ˆèŠ‚ç‚¹å­˜åœ¨å°±å‹æ ˆï¼ï¼ï¼‰**ã€‚
3. é‡å¤2çš„è¿‡ç¨‹ï¼Œ ç›´åˆ°æ ˆç©ºäº†ï¼Œ ç»“æŸã€‚

åˆç†æ€§:
å·¦æ ‘ä¼˜å…ˆå³æ ‘ï¼Œ å·¦æ ‘ä¸å¤„ç†å®Œä¸èƒ½å¤„ç†å³æ ‘ã€‚
**å…ˆå‹å³ï¼Œå†å‹å·¦ã€‚ æ ˆçš„åè¿›å…ˆå‡ºç‰¹æ€§ï¼å·¦è¢«ä¼˜å…ˆå¤„ç†ï¼Œ å·¦æ ‘è¢«å¤„ç†åˆä¼šå¸¦æ¥æ–°çš„å·¦å³èŠ‚ç‚¹(å¦‚æœå­˜åœ¨)ï¼Œ é‚£ä¹ˆå¾ªç¯è¿™ä¸ªè¿‡ç¨‹ã€‚ç›´åˆ°å·¦æ ‘å¤„ç†å¹²å‡€ï¼Œ ç„¶åå¤„ç†å³æ ‘ï¼ˆä¹Ÿæ˜¯è¿™å¥—é€»è¾‘ï¼‰ã€‚**

`ä»£ç `
```java
    //æäº¤ä¿®æ”¹å‡½æ•°å ->preorderTraversal
    public List<Integer> preorderTraversalUnRec(TreeNode head) {
        List<Integer> list= new ArrayList<>();
        if(head != null){
            //ç”³è¯·ä¸€ä¸ªæ ˆ
            Stack<TreeNode> stack = new Stack<>();
            //å…ˆå‹æ ¹èŠ‚ç‚¹
            stack.push(head);
            while(!stack.isEmpty()){
                //å¼¹æ ˆå¤„ç†(åŠ å…¥åˆ—è¡¨)ï¼Œ è¿™é‡Œå¤ç”¨å˜é‡head.
                head = stack.pop();
                list.add(head.val);

                //å…ˆå‹å³å­æ ‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if(head.right != null){
                    stack.push(head.right);
                }
                //åå‹å·¦å­æ ‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if(head.left != null){
                    stack.push(head.left);
                }
            }
        }
        //è¿”å›ç»“æœã€‚
        return list;
    }
```

##### **005 [ä¸­åºéå†-éé€’å½’](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)**
å¦‚æœæ²¡é˜…è¯»ï¼Œ ä¼˜å…ˆçœ‹`004`å‰é¢çš„å‡ æ®µè¯ã€‚

ä¸­åºçš„å¤„ç†æ–¹å¼: 
1. å°½å¯èƒ½æ·±çš„å¾€å·¦è¾¹ç•Œèµ°ï¼Œç›´åˆ°èµ°å°½ï¼ˆä¸èƒ½ç»§ç»­`.left`èµ°äº†ï¼‰ã€‚
2. å›é€€åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹(è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘æˆ–è€…å·¦å­æ ‘è¢«è®¿é—®è¿‡äº†)ï¼Œ é‚£ä¹ˆå¤„ç†è¿™ä¸ªæ ¹èŠ‚ç‚¹ã€‚ ç„¶åå°è¯•å‘å³èµ°ã€‚
3. ä»¥ä¸Šè§„åˆ™é€‚ç”¨ä»»æ„æ•´æ£µæ ‘åŠå…¶å­æ ‘ã€‚

ç®—æ³•æµç¨‹:
1. ç”³è¯·ä¸€ä¸ªæ ˆ(Javaå†…ç½®æ ˆæˆ–è€…å…¨å±€é™æ€æ•°ç»„æ‰‹å†™æ ˆ)ï¼Œ **curè®°å½•headèŠ‚ç‚¹ï¼Œ ç„¶åéå†å¼€å§‹**
2. curæ²¿ç€"å·¦è¾¹ç•Œ"è·¯å¾„ä¸€ç›´èµ°ï¼Œ æ”¶é›†èŠ‚ç‚¹åˆ°æ ˆä¸­ã€‚ç›´åˆ°curä¸ºnullã€‚
3. æ ˆä¸­å¼¹å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼ˆcurå›é€€åˆ°ä¸Šä¸€ä¸ªä¸”æ²¡å¤„ç†çš„èŠ‚ç‚¹ï¼‰, å¤„ç†å®ƒã€‚ å°è¯•å¾€å³èµ°`cur = cur.right`ã€‚
4. é‡å¤2çš„è¿‡ç¨‹ï¼Œ ç›´åˆ°curå¾€å³èµ°ä¸ºnullå¹¶ä¸”ä¸èƒ½é€šè¿‡æ ˆæ‰¾åˆ°ä¸Šä¸€ä¸ªåˆ°è¾¾ä½†æœªå¤„ç†çš„èŠ‚ç‚¹ã€‚ **äººè¯:å¾ªç¯ç»ˆæ­¢æ¡ä»¶æ ˆä¸ºç©ºä¸”curä¹Ÿä¸ºç©ºã€‚**

`ä»£ç `:
```java
    //éé€’å½’ä¸­åºç‰ˆæœ¬: æäº¤ä¿®æ”¹å‡½æ•°å->inorderTraversal
    public List<Integer> inorderTraversalUnRec(TreeNode head) {
        List<Integer> list = new ArrayList<>();
        if(head != null){
            //ç”³è¯·ä¸€ä¸ªæ ˆ
           var stack = new Stack<TreeNode>();
           //cur: éå†äºŒå‰æ ‘,åˆå§‹åŒ–ä¸ºhead
           var cur = head;
           //å¾ªç¯æ¡ä»¶ æ ˆä¸ä¸ºç©ºæˆ–è€…curä¸ä¸ºnull
           while(!stack.isEmpty() || cur != null){
               if(cur != null){
                   //ç®—æ³•æµç¨‹æ­¥éª¤2
                   
                   //å‹æ ˆ
                   stack.push(cur);
                   //ç»§ç»­å¾€å·¦èµ°ï¼Œ ä¸åˆ°å°½å¤´ä¸å›å¤´ã€‚
                   cur = cur.left;
               }
               else{
                   //ç®—æ³•æµç¨‹æ­¥éª¤3
                   
                   //å¼¹æ ˆ
                   cur = stack.pop();
                   //å¤„ç†ï¼ˆåŠ å…¥åˆ—è¡¨ï¼‰
                   list.add(cur.val);
                   //å°è¯•å¾€å³èµ°ã€‚
                   cur = cur.right;
               }
           }
        }
        return list;
    }
```

##### **006 [ååºéå†-éé€’å½’](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)**
å¦‚æœæ²¡é˜…è¯»ï¼Œ ä¼˜å…ˆçœ‹`004`å‰é¢çš„å‡ æ®µè¯ã€‚

æœ¬é¢˜è¯´æ˜ä¸¤ç§è§£æ³•
###### è§£æ³•ä¸€: åŒæ ˆå®ç°ã€‚
è§£æ³•ä¸€å¿…é¡»å…ˆäº†è§£`004`æ€è·¯ã€‚

ååºåŒæ ˆå®ç°åˆ†æ:
å…ˆåºéå†éé€’å½’å®ç°ï¼Œ é€šè¿‡å¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œç„¶åå…ˆå‹å³æ ‘åå‹å·¦æ ‘ã€‚
å€Ÿæ­¤ï¼Œ å®ç°*æ ¹ > å·¦ > å³*çš„é¡ºåºã€‚
å¯¹æ¯”ååºéå†ï¼Œ*å·¦ > å³ > æ ¹*çš„ä¼˜å…ˆçº§ã€‚ è§‚å¯Ÿä¸€ä¸‹ï¼Œ å‘ç°æ ¹åœ¨æœ€åï¼Œ é€†ç½®ä¸€ä¸‹ï¼Œ *æ ¹ > å³ > å·¦*ã€‚
ï¼ *æ ¹ > å³ > å·¦*å¾ˆå¥½å®ç°ã€‚ åªéœ€è¦æ”¹é€ ä¸€ä¸‹å…ˆåºéå†çš„å¤„ç†æ–¹å¼ï¼Œ
**å…ˆå‹å·¦æ ‘åå‹å·¦æ ‘**ã€‚ æ€ä¹ˆé€†ç½®å‘¢ï¼Ÿç”¨ä¸€ä¸ªæ ˆ!åœ¨å¤„ç†çš„æ—¶å€™ä¸å¤„ç†è€Œæ˜¯æ”¶é›†èµ·æ¥ï¼Œ ç„¶åç»Ÿä¸€å¤„ç†è€Œä¸”æ•´ä½“è¾“å‡ºä¸è¾“å…¥å®Œå…¨é€†åºäº†ã€‚

ç®—æ³•æµç¨‹:
1. ç”³è¯·ä¸¤ä¸ªæ ˆ(Javaå†…ç½®æˆ–è€…å…¨å±€é™æ€æ•°ç»„å®ç°æ ˆ)ï¼Œ ä¸€ä¸ªæ ˆstackåŒå…ˆåºéå†ä¸€æ ·ï¼ˆæ ¹èŠ‚ç‚¹å…¥æ ˆï¼‰ï¼Œ å¦ä¸€ä¸ªæ ˆcollectç”¨æ”¶é›†ä»£æ›¿å¤„ç†è¿™ä¸€æ­¥ã€‚
2. å¼¹æ ˆå°†å¼¹å‡ºèŠ‚ç‚¹ä¿å­˜åœ¨å˜é‡curä¸­ï¼Œ **å°†curæ”¶é›†èµ·æ¥ï¼ˆcurå‹å…¥collectï¼‰ï¼** **å…ˆå‹å·¦æ ‘åå‹å³å­æ ‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚**
3. é‡å¤2çš„è¿‡ç¨‹ç›´åˆ°æ ˆä¸ºç©ºã€‚
4. è¾“å‡ºæ”¶é›†æ ˆcollectï¼ŒæŒ‰è¾“å‡ºé¡ºåºå¤„ç†ã€‚

```java
 //åŒæ ˆè¿­ä»£å®ç°ååºéå† å‡½æ•°å->postorderTraversal
    public List<Integer> postorderTraversalTwoStacks(TreeNode head) {
        List<Integer> list = new ArrayList<>();
        if(head != null) {
            //æ­¥éª¤1:ç”³è¯·ä¸¤ä¸ªæ ˆ, ä¸€ä¸ªå¸¸è§„æ ˆstack å¦ä¸€æ”¶é›†æ ˆcollect
           var stack = new Stack<TreeNode>();
           var collect = new Stack<TreeNode>();
           //æ­¥éª¤1ï¼šæ ¹èŠ‚ç‚¹å…¥æ ˆ
            stack.push(head);

            //æ­¥éª¤3:å¾ªç¯æ­¥éª¤2ï¼Œç›´åˆ°æ ˆstackä¸ºç©ºã€‚
            while(!stack.isEmpty()){
                //æ­¥éª¤2:å¼¹æ ˆï¼Œ å¤ç”¨head
                head = stack.pop();
                //æ­¥éª¤2: æ”¶é›†æ ˆæ”¶é›†èŠ‚ç‚¹(æ›¿ä»£å¸¸è§„å¤„ç†)
                collect.push(head);

                //æ­¥éª¤2:å…ˆå‹å·¦å­æ ‘åå‹å³å­æ ‘
                if(head.left != null){
                    stack.push(head.left);
                }

                if(head.right != null){
                    stack.push(head.right);
                }
            }

            //æ­¥éª¤4:é€†åºè¾“å‡ºå¤„ç†æ”¶é›†æ ˆ
            while(!collect.isEmpty()){
                list.add(collect.pop().val);
            }
        }
        //è¿”å›ç»“æœ
        return list;
    }
```

###### è§£æ³•äºŒ: å•æ ˆå®ç°(ä¼˜äºè§£æ³•ä¸€)ğŸ«¡
èƒ½å¦å°‘ç”¨ä¸€ä¸ªæ ˆå‘¢? å…ˆåºéå†ï¼Œä¸­åºéå†éƒ½ç”¨ä¸€ä¸ªæ ˆï¼Œ ååºç”¨ä¸¤ä¸ªæ ˆæ˜¯ä¸æ˜¯ä¸å¤ªæ²¡æ’é¢äº†ã€‚

æˆ‘ä»¬é‡‡ç”¨é—®ç­”å¼å’Œ"ä¸€ä¸ªå¯é‡å¤åˆ©ç”¨çš„æ ‡å¿—"æ¥è¯´æ˜ç®—æ³•æµç¨‹ã€‚
æƒ³è±¡ä¸€ä¸‹ï¼Œå¼ ä¸‰å½“å‰åœ¨æœ€åˆçš„å®¶ä¸­(å‡è®¾æ‘è½é‡Œé‚»é‡Œåˆ†å¸ƒå¯ä»¥è®¤ä¸ºä¸€ç§äºŒå‰æ ‘ç»“æ„ï¼Œ å¼ ä¸‰å®¶æ­£å¥½åœ¨æ‘è½çš„æ ¹èŠ‚ç‚¹å¤„)ï¼Œ å¼ ä¸‰æ˜¯ä¸ªè·¯ç—´ï¼Œ ä»–è¦æŒ‰ç…§ååºéå†ä¾æ¬¡æ‹œè®¿ä»–çš„é‚»å±…ä»¬æœ€åå›åˆ°è‡ªå·±çš„å®¶ä¸­ã€‚ ç°åœ¨æˆ‘è¦å¸®åŠ©ä»–æ‰¾åˆ°æ­£ç¡®çš„é¡ºåºã€‚
å¼ ä¸‰æé—®
>1. æ—ç™½:å¼ ä¸‰è‚¯å®šä¸èƒ½ç›´æ¥ä¸Šæ¥å›åˆ°ä»–å®¶ä¸­ï¼ˆå› ä¸ºååºéå†çš„ç‰¹ç‚¹ï¼‰ã€‚
>2. å¼ ä¸‰:æˆ‘è¯¥å‰å¾€å“ªä¸ªèŠ‚ç‚¹æ‹œè®¿é‚»å±…å‘¢å‘¢? å·¦æˆ–è€…å³ï¼Ÿ ä¸ºä»€ä¹ˆ?
>3. æˆ‘:å¦‚æœä½ å·¦èŠ‚ç‚¹æœ‰é‚»å±…å­˜åœ¨çš„è¯ï¼Œé‚£ä¹ˆä½ åº”è¯¥ä¼˜å…ˆå‰å¾€å·¦èŠ‚ç‚¹å¤„ã€‚å¦åˆ™ï¼Œ åº”è¯¥å»å³èŠ‚ç‚¹å¤„ã€‚
>4. å¼ ä¸‰:å¥½çš„ï¼Œ æˆ‘åº”è¯¥ä¸€ç›´å‘å·¦èµ°ã€‚ç°åœ¨æˆ‘èµ°åˆ°æœ€å·¦çš„åœ°æ–¹äº†ã€‚ç°åœ¨æˆ‘æ‹œè®¿ç»“æŸäº†ã€‚
>5. æ—ç™½: å¼ ä¸‰ï¼Œåº”è¯¥å›é€€åˆ°ä¸Šä¸€ä¸ªä½ç½®äº†ã€‚ å¥½åœ¨ï¼Œå¼ ä¸‰ç”¨äº†è®°å·(æ ˆ)è®°å½•äº†ä¸Šä¸€æ¬¡çš„ä½ç½®é‚»å±…å®¶ã€‚ç°åœ¨ï¼Œ å®ƒå¯ä»¥é¡ºåˆ©è¿”å›ä¸Šä¸€ä¸ªä½ç½®äº†ã€‚
>6. å¼ ä¸‰: ç°åœ¨æˆ‘ä¸åº”è¯¥æ‹œè®¿è¿™ä¸ªé‚»å±…ï¼Œ æˆ‘åº”è¯¥å°è¯•æ‹œè®¿æˆ‘çš„å³é‚»å±…ä»¬ã€‚ ä¸å¯¹ï¼Œ æŒ‰ç…§"ä½ "å…ˆå‰çš„è¯´æ³•ï¼ˆ`ç¬¬3æ¡å¯¹è¯`ï¼‰ï¼Œ æˆ‘åº”è¯¥ç»§ç»­æ‹œè®¿æˆ‘çš„å·¦é‚»å±…ï¼Œä½†æˆ‘å·²ç»æ‹œè®¿è¿‡äº†ã€‚
>7. æˆ‘:å¥½çš„ï¼Œ æˆ‘å¾—æ›´æ­£ä¸€ä¸‹ ã€‚å¦‚æœä½ å·¦èŠ‚ç‚¹æœ‰é‚»å±…å­˜åœ¨çš„è¯ä¸”ä½ æ²¡æœ‰è®¿é—®è¿‡ï¼Œä½ åº”è¯¥è®¿é—®å·¦èŠ‚ç‚¹ã€‚
>8. å¼ ä¸‰: å¦‚ä½•çŸ¥é“è®¿é—®è¿‡å‘¢?
>9. æˆ‘: åšä¸ªæ ‡å¿—(pre)å°±å¥½äº†å‘€ã€‚ç”šè‡³å¯ä»¥åªåšä¸€ä¸ªæ ‡å¿—ï¼Œ ä½ çœ‹ï¼Œ å¦‚æœæˆ‘æŠŠè¿™ä¸ªæ ‡å¿—è®°å½•å·¦èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¼ ä¸‰ä½ ä¸åº”è¯¥å‰å¾€å·¦èŠ‚ç‚¹ã€‚ å¦‚æœï¼Œ è¿™ä¸ªæ ‡å¿—è®°å½•å³èŠ‚ç‚¹äº†ï¼Œé‚£ä¹ˆä½ åŒæ ·ä¸åº”è¯¥å‰å¾€å·¦èŠ‚ç‚¹ã€‚ å› ä¸ºå·¦æ¯”å³å…ˆåˆ°ã€‚
>10. å¼ ä¸‰:æˆ‘ä¼¼ä¹å¥½åƒæ˜ç™½æ€ä¹ˆé¿å…é‡å¤è®¿é—®æˆ‘çš„å³èŠ‚ç‚¹é‚»å±…äº†ã€‚ä¸€æ–¹é¢ï¼Œæˆ‘å¾—çœ‹å³èŠ‚ç‚¹æœ‰æ— æˆ‘çš„é‚»å±…ä»¬ï¼Œ è¿˜æœ‰æˆ‘åº”è¯¥çœ‹æ˜¯å¦æ ‡è®°äº†å³èŠ‚ç‚¹ã€‚
å¦åˆ™ï¼Œæˆ‘å°±åº”è¯¥å‰å¾€å³èŠ‚ç‚¹ã€‚
>11. æˆ‘ï¼šå¯¹ï¼ä½ åšäº†è®°å·å¯ä»¥éšæ—¶è¿”å›ã€‚åˆæœ‰äº†ä¸€ä¸ªé‡å¤åˆ©ç”¨çš„æ ‡å¿—é¿å…äº†é‡å¤è®¿é—®ã€‚

çœ‹äº†è¿™æ®µæŒºå°´å°¬çš„å¯¹è¯ã€‚
å¼ ä¸‰åšçš„è®°å·å°±æ˜¯æ ˆï¼Œ æ ‡å¿—å°±æ˜¯ä¸Šæ¬¡å¤„ç†çš„èŠ‚ç‚¹ã€‚

ç®—æ³•æµç¨‹:
1. ç”³è¯·ä¸€ä¸ªæ ˆ(Javaå†…ç½®æ ˆæˆ–è€…å…¨å±€é™æ€æ•°ç»„æ‰‹å†™æ ˆ), å°†æ ¹èŠ‚ç‚¹å‹å…¥æ ˆä¸­ã€‚å£°æ˜ä¸€ä¸ªpreèŠ‚ç‚¹è®°å½•ä¸Šæ¬¡å¤„ç†çš„èŠ‚ç‚¹ï¼Œ åˆå§‹åŒ–ä¸ºnullã€‚curä»headå‡ºå‘ã€‚
2. å¦‚æœå½“å‰èŠ‚ç‚¹curçš„å·¦å­æ ‘ä¸ä¸ºç©º å¹¶ä¸” preèŠ‚ç‚¹æ²¡æœ‰æ ‡è®°å½“å‰èŠ‚ç‚¹curçš„å·¦å­æ ‘å’Œå³å­æ ‘ã€‚ é‚£ä¹ˆå‰å¾€å·¦å­æ ‘ã€‚
3. å¦‚æœ2ä¸æˆç«‹ï¼Œ å°è¯•å‰å¾€å³å­æ ‘ã€‚ å¦‚æœå³å­æ ‘ä¸ä¸ºnull,ä¸”preæ²¡æœ‰æ ‡è®°å½“å‰èŠ‚ç‚¹curçš„å³å­æ ‘ã€‚ é‚£ä¹ˆå‰å¾€å³å­æ ‘ã€‚
4. è‹¥3ä¸æˆç«‹(2ä¹Ÿä¸æˆç«‹)ï¼Œ å¤„ç†å½“å‰èŠ‚ç‚¹curã€‚å…¶åï¼Œpreæ ‡è®°è¿™ä¸ªèŠ‚ç‚¹`pre = cur`ï¼Œç„¶åå¼¹æ ˆå›é€€åˆ°ä¸Šä¸€å¤„ã€‚
5. é‡å¤å¯¹2ï¼Œ3ï¼Œ4çš„åˆ¤æ–­ã€‚ç›´åˆ°æ ˆstackä¸ºç©ºï¼Œç»“æŸã€‚

`å¯ä»¥è¿™æ ·ç†è§£ï¼Œ curå¤„ç†çš„å§‹ç»ˆæ˜¯â€œå¶èŠ‚ç‚¹â€ï¼Œ å¤„ç†å®Œcurå°±æŠŠcurä»æ•´é¢—æ ‘ä¸­åˆ é™¤äº†åªä¸è¿‡æ˜¯"ä¼ªåˆ é™¤", preè¿™ä¸ªè®°å½•ä¸Šä¸€æ¬¡åˆ°è¾¾çš„èŠ‚ç‚¹å°±å……å½“äº†ä¼ªåˆ é™¤çš„ä½œç”¨ã€‚ è¿™é‡Œçš„"å¶èŠ‚ç‚¹"æ˜¯ä¼ªåˆ é™¤è§’åº¦çš„è§†è§’`ã€‚

`ä»£ç `
 ```java   
    //å•æ ˆè¿­ä»£å®ç°ååºéå† å‡½æ•°å->postorderTraversal
    public List<Integer> postorderTraversalOneStack(TreeNode head){
        List<Integer> list = new ArrayList<>();
        if(head != null){
            //æ­¥éª¤1:ç”³è¯·æ ˆ
            var stack = new Stack<TreeNode>();
            /// è¿™é‡Œå¤ç”¨äº†headä½œä¸ºpre, å½“headç»å†æ­¥éª¤4ä¹‹åè¡¨ç¤ºä¸Šæ¬¡å¤„ç†çš„èŠ‚ç‚¹ï¼Œ å¦åˆ™æ˜¯æ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
            stack.push(head);
            TreeNode cur = head;
            //æ­¥éª¤5ï¼š å¾ªç¯åˆ¤æ–­æ­¥éª¤2,3,4->æ ˆä¸ºç©ºã€‚
            while(!stack.isEmpty()){
                cur = stack.peek();
                //æ­¥éª¤2 æ¡ä»¶åˆ¤æ–­: å·¦ä¸ä¸ºç©ºï¼Œ ä¸”å·¦å³éƒ½æœªè®¿é—®è¿‡ã€‚è¿›å…¥å·¦å­æ ‘
                if(cur.left != null && head != cur.left && head != cur.right){
                    stack.push(cur.left);
                }
                //æ­¥éª¤3 æ¡ä»¶åˆ¤æ–­: å³ä¸ä¸ºç©ºï¼Œ ä¸”å³èŠ‚ç‚¹æœªè®¿é—®è¿‡ã€‚ è¿›å…¥å³å­æ ‘
                else if(cur.right != null && head != cur.right){
                    stack.push(cur.right);
                }
                else{
                    //æ­¥éª¤4

                    //å¤„ç†å½“å‰èŠ‚ç‚¹
                    list.add(cur.val);
                    //æ ‡è®°ä¸Šæ¬¡å¤„ç†çš„èŠ‚ç‚¹
                    head = cur;
                    //å¼¹æ ˆ
                    stack.pop();
                }
            }
        }
        return list;
    }
```

##### **007 001~006æ—¶é—´å¤æ‚åº¦æ€»ç»“å’Œå” å—‘**
å‰é¢6é“é¢˜(å®åˆ™3é“é¢˜7ç§å†™æ³•)æ‰‹æ“å®Œäº†å—ï¼Ÿ
æ— è®ºæ˜¯é€’å½’è¿˜æ˜¯éé€’å½’ã€‚
æ—¶é—´å¤æ‚åº¦:$O(n)$ï¼Œ å› ä¸ºè¦éå†æ‰€æœ‰çš„èŠ‚ç‚¹æ•°ã€‚
ç©ºé—´å¤æ‚åº¦:$O(h)$, hæ˜¯é€’å½’æ·±åº¦å’Œæ ˆçš„æœ€å¤§é•¿åº¦ã€‚ ååºéå†çš„è§£æ³•ä¸€åŒæ ˆå®ç°ç©ºé—´å¤æ‚åº¦:$O(n)$,é¢å¤–å¤šäº†ä¸€ä¸ªæ”¶é›†æ ˆè¦æ”¶é›†æ‰€æœ‰çš„èŠ‚ç‚¹æ•°ã€‚

1. æœ‰æ²¡æœ‰ä¼˜åŒ–ç©ºé—´çš„ç®—æ³•?èƒ½åšåˆ°$O(1)$
æœ‰ï¼ ä¸€ç§éå†äºŒå‰æ ‘çš„é…·ç‚«æ–¹æ³•ã€‚ Morriséå†, å®ƒå…·æœ‰$O(n)$çš„æ—¶é—´å¤æ‚åº¦å’Œ$O(1)$çš„ç©ºé—´å¤æ‚åº¦
è¯¥å†…å®¹åç»­0XXåºå·å¤„å‡ºç°ï¼Œ å±äºæ‹“å±•å†…å®¹ã€‚ åœ¨æŸäº›ç®—æ³•é¢˜ä¸Šæœ‰å¥‡æ•ˆï¼Œ åŒæ ·æ˜¯è¿­ä»£å†™æ³•ä½†ä¸ç”¨æ ˆã€‚

2. äº†è§£äºŒå‰æ ‘éå†çš„é€’å½’éé€’å½’æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Ÿ
ç†è§£å‡½æ•°æ ˆå’Œæ˜¾ç¤ºæ ˆæ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œ ç†è§£é€’å½’èƒŒåæ ˆæ“ä½œå’Œæ ‘çš„å±‚æ¬¡æ“ä½œã€‚ç†Ÿæ‚‰è¿­ä»£å’Œé€’å½’çš„è½¬æ¢ï¼Œ é¿å…é€’å½’æ ˆæº¢å‡ºçš„é£é™©ï¼Œ ç‰¹å®šåœºæ™¯å¯ä»¥ç”¨è¿­ä»£ä»£æ›¿é€’å½’è·å–æ›´é«˜çš„æ€§èƒ½ä¼˜åŠ¿ï¼ˆæŸäº›æ•°æ®ç»“æ„ä¹Ÿæ˜¯å†…éƒ¨ç”¨è¿­ä»£ä»£æ›¿é€’å½’ï¼‰ã€‚é”»ç‚¼codingèƒ½åŠ›ï¼Œ è¿­ä»£å¾€å¾€æ¯”é€’å½’å†™æ³•æœ‰éš¾åº¦ï¼Œä¸å¦‚åè€…æ˜“æ‡‚ã€‚
ç†Ÿç»ƒå¯¹å®¹å™¨æ•°ç»„ï¼Œæ ˆï¼Œé˜Ÿåˆ—è¿™äº›ç»“æ„çš„ä½¿ç”¨ã€‚


##### **008 [å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)**
**é‡ç‚¹æŒæ¡ä¼˜åŒ–ç‰ˆçš„å±‚åºéå†å¤„ç†æ–¹æ³•ã€‚å³è§£æ³•2**

**åŸºç¡€å›é¡¾: å±‚åºéå†: å…ˆå¤„ç†å®Œå½“å‰å±‚ç„¶åå¤„ç†ä¸‹ä¸€å±‚ã€‚æŒ‰å±‚åˆ†ä¼˜å…ˆçº§** 
å…¶åŸºæœ¬æµç¨‹æ˜¯:
1. ç”³è¯·ä¸€ä¸ªé˜Ÿåˆ—ï¼ˆå› ä¸ºé˜Ÿåˆ—çš„å…ˆè¿›å…ˆå‡ºçš„ç‰¹æ€§ç¬¦åˆå±‚çº§ä¼˜å…ˆçš„åŸåˆ™ï¼‰ï¼Œ æ ¹èŠ‚ç‚¹å…¥é˜Ÿã€‚
2. å‡ºé˜Ÿï¼Œ ç„¶åå¯¹è¯¥èŠ‚ç‚¹å¤„ç†ï¼ˆæ‰“å°ï¼‰ï¼Œ å°†å·¦å³å­æ ‘çš„æ ¹èŠ‚ç‚¹å…¥é˜Ÿï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚
3. é‡å¤2ç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºã€‚

```java
    //å¹¿åº¦ä¼˜å…ˆéå†æ‰“å°
    public void levelOrder(TreeNode head){
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(head);
        if(!queue.isEmpty()){
            head = queue.poll();
            System.out.print(head.val + " ");
            if(head.left != null){
                queue.offer(head.left);
            }
            if(head.right != null){
                queue.offer(head.right);
            }
        }
    }
```

`ä¼ ç»Ÿçš„å†™æ³•ï¼Œ ç®€å•çš„å¹¿åº¦ä¼˜å…ˆéå†ä¸€ä¸‹å®Œäº‹äº†ã€‚ç¼ºç‚¹ï¼Œ æ¯”å¦‚ï¼Œ å°è¯•ç”¨ä¼ ç»Ÿçš„å†™æ³•è§£å†³ä¸Šé¢008é“¾æ¥çš„OJé¢˜å°±ä¸è¡Œã€‚`
ä¸ºä»€ä¹ˆï¼Ÿ å¦‚æœä½ çœ‹äº†ä¸€ä¸‹ï¼Œ ä½ ä¼šå‘ç°é¢˜ç›®è¦æ±‚ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ†å±‚ï¼Œ å³æ˜ç¡®çŸ¥é“å“ªäº›èŠ‚ç‚¹å±äºå“ªäº›å±‚ã€‚

**ç°åœ¨ä»‹ç»å‡çº§ç‰ˆçš„å±‚åºéå†**
###### **è§£æ³•ä¸€:å“ˆå¸Œè¡¨**
å“ˆå¸Œè¡¨è¿™ä¸ªç»“æ„ä½ åº”è¯¥ç†Ÿæ‚‰(å¦åˆ™ä½ åº”è¯¥è·³è¿‡è§£æ³•ä¸€æˆ–è€…å»äº†è§£å“ˆå¸Œè¡¨çš„çŸ¥è¯†)ï¼Œ è¿™é‡Œè¦è¿ç”¨Javaä¸­çš„`HashMap`ã€‚

`ä½¿ç”¨å“ˆå¸Œè¡¨å…³è”æ¯ä¸ªèŠ‚ç‚¹å’Œå…¶æ‰€åœ¨å±‚æ•°`ã€‚

å…¶åŸºæœ¬æ€æƒ³æ˜¯åœ¨ä¼ ç»Ÿå¹¿åº¦ä¼˜å…ˆéå†ä¸Šæ”¹è¿›:
è¡¥å……ä¸€ä¸‹.
1. é¢å¤–ç»´æŠ¤ä¸€å¼ è¡¨çš„ä¿¡æ¯ã€‚ åˆå§‹å“ˆå¸Œè¡¨ç»‘å®šå¤´èŠ‚ç‚¹å’Œ0å±‚åœ¨ä¸€èµ·ã€‚
2.  `List<List<Integer>>`ï¼Œä½ å¯ä»¥è®¤ä¸ºçºµå‘æ˜¯ä¸€ä¸ªè¡Œå‘é‡æ•°ç»„ï¼Œ æ¯æ¬¡å‡ºé˜Ÿæ—¶è¦ä»è¡¨é‡Œè·å–è¯¥èŠ‚ç‚¹çš„å±‚æ•°ä¿¡æ¯ã€‚ç¬¬ä¸€ï¼Œæ³¨æ„å½“å‰å±‚çš„è¡Œå‘é‡æ˜¯å¦å­˜åœ¨å¦åˆ™åº”è¯¥åˆ›å»ºä¸€ä¸ª(`if (ans.size() == level) `)ã€‚ç¬¬äºŒï¼Œå¯¹å·¦å³èŠ‚ç‚¹å…¥é˜Ÿè¦æ³¨æ„å¯¹è¡¨çš„æ›´æ–°ï¼Œ æ›´æ–°å±‚æ•°åº”è¯¥æ˜¯ä¸‹ä¸€å±‚ã€‚

`ä»£ç `:
```java
    /**
     * æ­¤æ³•ç”¨äº†å“ˆå¸Œè¡¨ï¼Œå¾ˆæ‹‰è·¨ã€‚ ä½†å»ºè®®ç†Ÿæ‚‰ä¸€ä¸‹codingå†™æ³•ã€‚
     * æäº¤æ—¶æŠŠåç¼€1å»æ‰ã€‚
     * <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">...</a>
     * @param head root
     * @return the level order traversal of its nodes' values
     */
    public List<List<Integer>> levelOrder1(TreeNode head) {
        List<List<Integer>> ans = new ArrayList<>();
        if(head != null){
            //ç”³è¯·ä¸€ä¸ªé˜Ÿåˆ—
            Queue<TreeNode> queue = new LinkedList<>();
            //ç”³è¯·å“ˆå¸Œè¡¨: keyï¼šèŠ‚ç‚¹æŒ‡é’ˆ->valueï¼šèŠ‚ç‚¹æ‰€åœ¨å±‚æ•°
            HashMap<TreeNode, Integer> levels = new HashMap<>();

            //åˆå§‹å¯¹é˜Ÿåˆ—å’Œå“ˆå¸Œè¡¨å¤„ç†
            queue.offer(head);
            levels.put(head, 0);

            while(!queue.isEmpty()) {
                //å¤„ç†é˜Ÿåˆ—ä¸€ä¸ªèŠ‚ç‚¹
                head = queue.poll();
                //è·å–å½“å‰å±‚æ•°
                int level = levels.get(head);
                //å¦‚æœå½“å‰å±‚æ•°ä¸å­˜åœ¨ï¼Œ åˆ™åˆ›å»ºã€‚
                if (ans.size() == level) {
                    ans.add(new ArrayList<>());
                }

                //å°†curèŠ‚ç‚¹çš„å€¼åŠ å…¥å½“å‰å±‚çš„åºåˆ—
                ans.get(level).add(head.val);

                //å¤„ç†curçš„å·¦å³ä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆå¦‚æœå­˜åœ¨åˆ™å…¥é˜Ÿï¼‰ï¼Œ å¹¶è®°å½•åœ¨ä¸‹ä¸€å±‚çš„å“ˆå¸Œè¡¨
                if (head.left != null) {
                    queue.offer(head.left);
                    levels.put(head.left, level + 1);
                }

                if (head.right != null) {
                    queue.offer(head.right);
                    levels.put(head.right, level + 1);
                }
            }
        }
        return ans;
    }
```

**æ€»ç»“:æ­¤æ³•å¤šç”¨äº†ä¸€ä¸ªå“ˆå¸Œè¡¨ç»´æŠ¤èŠ‚ç‚¹ä¸æ‰€åœ¨å±‚æ•°çš„ä¿¡æ¯ï¼Œ ç©ºé—´æœ‰äº†é¢å¤–å¼€é”€**


###### **è§£æ³•2:æŒ‰å±‚å¤„ç†**
å¯ä»¥ä¸ç”¨å®¹å™¨å¤„ç†ï¼Œ èƒ½ç”¨å¸¸æ•°ä¸ªå˜é‡è§£å†³çš„äº‹æƒ…ï¼Œ é¢å¤–ç”¨å®¹å™¨ç»´æŠ¤æ˜¯å¯¹ç©ºé—´çš„å¤šä½™æµªè´¹ã€‚

ç®—æ³•æµç¨‹:
1. ç”³è¯·é˜Ÿåˆ—(Javaå†…ç½®Queue, å…¨å±€é™æ€æ•°ç»„å®ç°é˜Ÿåˆ—å°†åœ¨è§£æ³•3ä¸­å‘ˆç°)ï¼Œ å°†å¤´èŠ‚ç‚¹å…¥é˜Ÿã€‚
2. è·å–å½“å‰å±‚çš„èŠ‚ç‚¹æ•°`size = queue.size()`, å†…éƒ¨å¾ªç¯å¤„ç†å®Œå½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹ã€‚
3. å†…éƒ¨å¾ªç¯é€»è¾‘ï¼Œ ä¼ ç»Ÿå†™æ³•ä¸€è‡´ï¼Œ å·¦å­æ ‘å³å­æ ‘å…¥é˜Ÿï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œ æ¯æ¬¡å¾ªç¯å°±æ„å‘³ç€å¤„ç†äº†ä¸€ä¸ªå½“å‰å±‚ç»“ç‚¹ï¼Œ`size--`ã€‚é‡å¤åˆ°å½“å‰å±‚ç»“ç‚¹å¤„ç†å®Œ`size == 0`ã€‚
4. é‡å¤2ï¼Œ3è¿‡ç¨‹ï¼Œ ç›´è‡³é˜Ÿåˆ—ä¸ºç©ºï¼Œ ç»“æŸã€‚

`ä»£ç `:
```java
     /**
     * é“¾æ¥åŒä¸Š
     * æäº¤æ—¶å°†å‡½æ•°å->levelOrder
     * @param head root
     * @return the level order traversal of its nodes' values
     */
    public List<List<Integer>> levelOrder2(TreeNode head){
        List<List<Integer>> ans = new ArrayList<>();
        if(head != null){
            //æ­¥éª¤1ï¼š ç”³è¯·é˜Ÿåˆ—ï¼Œ å¤´èŠ‚ç‚¹å…¥é˜Ÿã€‚
            var queue = new LinkedList<TreeNode>();
            queue.offer(head);
            //æ­¥éª¤4:é€»è¾‘æ”¹ä¸ºæŒ‰å±‚å¤„ç†ï¼Œ å¤–å¾ªç¯ä¸€æ¬¡å¤„ç†ä¸€å±‚ã€‚
            while(!queue.isEmpty()){
                //æ­¥éª¤2:è·å¾—å½“å‰å±‚å¤„ç†çš„èŠ‚ç‚¹ä¸ªæ•°
                int size = queue.size();
                //åˆ›å»ºè¯¥å±‚çš„åˆ—è¡¨
                List<Integer> list = new ArrayList<>(size);

                //æ­¥éª¤3: å¾ªç¯å¤„ç†å½“å‰å±‚çš„èŠ‚ç‚¹
                while(size-- > 0){
                    //æ­¥éª¤3 å‡ºé˜Ÿ ,headå¤ç”¨
                    head = queue.poll();
                    list.add(head.val);

                    //æ­¥éª¤3 å·¦å³å­æ ‘å…¥é˜Ÿï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if(head.left != null){
                        queue.offer(head.left);
                    }

                    if(head.right != null){
                        queue.offer(head.right);
                    }
                }
                ans.add(list);
            }
        }
        return ans;
    }
```

###### **`è§£æ³•3:å…¨å±€é™æ€æ•°ç»„é˜Ÿåˆ—`**
è¯·å…ˆçœ‹æœ¬é¢˜çš„è§£æ³•2.
å…·ä½“æ­¥éª¤æ˜¯ç”¨[é™æ€æ•°ç»„å……å½“é˜Ÿåˆ—](https://www.youtube.com/watch?v=2njEmxGatBE&list=PLvKfL6GtwDxwuyrpAJfU3HTnPZl4WnraE&index=14)ï¼Œ ä»…é™ç®—æ³•é¢˜ä½¿ç”¨ã€‚
**1. æœ¬é¢˜æ•°æ®é‡[0,2000]ï¼Œ è¿™æ„å‘³ç€å¦‚æœä¸€ç›´å…¥é˜Ÿæœ€åçš„æƒ…å†µå°±æ˜¯æ•°ç»„å®¹çº³2000ä¸ªæ•°æ®ï¼Œæ‰€ä»¥å¼€ä¸€ä¸ª2000çš„æ•°ç»„å……å½“é˜Ÿåˆ—.**
**2. è®¾ç½®é™æ€å­—æ®µl,rã€‚åˆå§‹`[l,r)`, `l==r`æ—¶é˜Ÿåˆ—ä¸ºç©ºï¼Œ é˜Ÿåˆ—é•¿åº¦ä¸º`r-l`ã€‚**
3. å…¶å®ƒæ­¥éª¤åŒè§£æ³•2ï¼Œåªæ˜¯é˜Ÿåˆ—æ”¹æˆé™æ€æ•°ç»„å®ç°ï¼Œ è´´è¿‘ç¬”è¯•å’Œç®—æ³•æ¯”èµ›çš„å†™æ³•ã€‚

`ä»£ç `
```java
    /**
     * è§£æ³•3ï¼š100%çš„é€Ÿåº¦ã€‚ å…¨å±€é™æ€æ•°ç»„
     * æäº¤æ—¶å‡½æ•°å->levelOrder
     * æœ¬é¢˜æ•°æ®é‡[0,2000]ï¼Œ æ‰€ä»¥å¼€ä¸€ä¸ª2000çš„æ•°ç»„å……å½“é˜Ÿåˆ—.
     * éœ€è¦äº†è§£æ•°ç»„å®ç°é˜Ÿåˆ—ã€‚
     */
    public static int MAX = 2000;//æ•°æ®é‡å¢å¤§å°±æ›´æ–°è¿™ä¸ªå€¼
    public static TreeNode[] queue = new TreeNode[MAX];
    public static int l,r; //l==ræ—¶ä¸ºç©ºï¼Œ [l,r)
    private List<List<Integer>> ans = new ArrayList<>();
    public List<List<Integer>> levelOrder3(TreeNode head){
        if(head != null){
            l = r = 0;//é‡ç½®ä¸º0
            queue[r++] = head;
            while(l!=r){
                int size = r - l;
                ArrayList<Integer> list = new ArrayList<>(size);
                while(size-- > 0){
                    TreeNode cur = queue[l++];
                    list.add(cur.val);

                    if(cur.left != null){
                        queue[r++] = cur.left;
                    }

                    if(cur.right != null){
                        queue[r++] = cur.right;
                    }
                }
                ans.add(list);
            }
        }
        return ans;
    }
```


###### **è§£æ³•4:åŠ›æ‰£100%å‡»è´¥**

å¯¹äºæŸäº›'å¼ºè¿«ç—‡'æ‚£è€…ï¼Œ æ¯”å¦‚æˆ‘ã€‚ä¸åˆ°100%æ˜¯ä¸ä¼šç½¢ä¼‘çš„ã€‚
é‡‡ç”¨â€œä½œå¼Šâ€çš„æ‰‹æ®µï¼š
ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢å³å°±æ˜¯å…ˆåºéå†çš„é€’å½’å†™æ³•ã€‚ å¸¸æ•°é¡¹æ—¶é—´å¥½ä¸€ç‚¹ã€‚
è™½ç„¶ä¸æ˜¯å±‚åºéå†çš„é¡ºåºï¼Œ ä½†æœ€ç»ˆå»ºç«‹çš„`List<List<Integer>>`çš„ç»“æœå’Œå±‚åºéå†ä¸€è‡´ã€‚

`å¤§åƒä¸–ç•Œï¼Œæ— å¥‡ä¸æœ‰ã€‚100%è¾¾æˆï¼ˆå¦‚æœå·å¸¸æ•°æ—¶é—´å¯èƒ½è¿™ç§å†™æ³•ä¹Ÿåšä¸åˆ°100%äº†ï¼‰`
```java

    private  List<List<Integer>> ans =new ArrayList();

    public List<List<Integer>> levelOrder(TreeNode root) {
        dfs(root,0);
        return ans;
    }

    public void dfs(TreeNode root,int depth){
        if(root==null)
            return ;
        if(depth == ans.size()){
            ans.add(new ArrayList());
        }
        ans.get(depth).add(root.val);
        dfs(root.left,depth+1);
        dfs(root.right,depth+1);
    }
```

##### **009 ZigZagéå†**
æœ¬é¢˜æä¾›4ç§è§£æ³•ï¼Œ é¦–å…ˆä½ éœ€è¦äº†è§£`008å±‚åºéå†`çš„æœ‰å…³å†…å®¹ï¼Œ å¦åˆ™å¾ˆéš¾çœ‹ä¸‹å»ã€‚
è§£æ³•1æœ€å¥½æƒ³ï¼Œ è§£æ³•2ç»ƒCodingï¼ˆå¯ä»¥è·³è¿‡ï¼‰;
è§£æ³•3å’Œ4ï¼ˆå¿…çœ‹ï¼‰:åŒç«¯é˜Ÿåˆ—å’Œå…¨å±€é™æ€æ•°ç»„ã€‚
ä»€ä¹ˆæ˜¯zigzag?
ä»‹ç»ï¼›
å‡è®¾æ ¹èŠ‚ç‚¹æ‰€åœ¨å±‚ä¸º0ï¼Œè¿™é‡Œå‡è®¾ä¸º0ä¸ºäº†æ–¹ä¾¿ï¼Œ æ ¹æ®å®é™…é€‰æ‹©ä¸º0æˆ–è€…1ã€‚
```diff
    /**
     *          1
     *        /  \
     *       2    3
     *     /    /  \
     *    4    5    6
     *       /  \
     *      7    8
     * æ¯å±‚è¾“å‡º:
     * level0 : 1
     * level1 : 3 2
     * level2 : 4 5 6
     * level3 : 8 7
     *      
     */       
```
å¯ä»¥å‘ç°ï¼Œå¶æ•°å±‚è·Ÿå±‚åºéå†ä¸€è‡´ï¼Œå¥‡æ•°å±‚è·Ÿå±‚åºéå†åè¿‡æ¥äº†ï¼ˆå¦‚1ï¼Œ3å±‚ï¼‰ã€‚

###### **è§£æ³•1:å±‚åºéå† + é€†åºå¤„ç†**
1. äº†è§£`008å±‚åºéå†`çš„æœ‰å…³å†…å®¹ã€‚ è¿™ç§è§£æ³•å¯ä»¥å¸®åŠ©ä½ å¤ä¹ å±‚åºéå†ç”¨çš„ã€‚
2. Javaäº†è§£ä¸€ä¸‹`Collections.reverse(List<?> list)`ï¼Œ è¿™ä¸ªé™æ€æ–¹æ³•å¯ä»¥å®ç°åˆ—è¡¨é€†åºã€‚ çŸ¥è¯†ç‚¹å°±è¿™äº›ï¼Œ å…¨æ˜¯æ¨¡æ¿äº†ã€‚

`ä»£ç `
```java
    //æäº¤æ—¶ä¿®æ”¹å‡½æ•°å->zigzagLevelOrder
    public List<List<Integer>> zigzagLevelOrder1(TreeNode head) {
            var ans = new ArrayList<List<Integer>>();
            if(head != null){
                LinkedList<TreeNode> queue = new LinkedList<>();
                queue.offer(head);
                while(!queue.isEmpty()){
                    int size = queue.size();
                    List<Integer> list = new ArrayList<Integer>();
                    while(size-- > 0){
                        head = queue.poll();
                        list.add(head.val);

                        if(head.left != null){
                            queue.offer(head.left);
                        }

                        if(head.right != null){
                            queue.offer(head.right);
                        }
                    }
                    ans.add(list);
                }
                //æ ¹èŠ‚ç‚¹å±‚ä¸ºç¬¬0å±‚, å¯¹å¥‡æ•°å±‚è¿›è¡Œé€†åº
                for(int i=1;i<ans.size();i+=2){
                    //Collectionså·¥å…·ç±»æœ‰ä¸ªreverseæ–¹æ³•å¯ä»¥é€†åºåˆ—è¡¨
                    Collections.reverse(ans.get(i));
                }
            }
            return ans;
    }
```

###### **`è§£æ³•2:ArrayList(å¯è·³)`**
è¿™ç§è§£æ³•å°±æ˜¯å‡è®¾åŸºæœ¬æ•°æ®ç»“æ„åªä¼šé¡ºåºè¡¨`Javaä¸­çš„ArrayList`ï¼Œ æ•°æ®ç»“æ„æ–°æ‰‹, ä¹Ÿä¸å…·æœ‰çº¯ç”¨æ•°ç»„ç©çš„ç»éªŒã€‚
 æ­¤æ³•å¯¹äºæ–°æ‰‹æ˜¯ä¸ªæ–¹æ³•! å¯¹äºè€æ‰‹å¯ä»¥ç»ƒç»ƒCodingã€‚
 è¿™ä¸ªæ–¹æ³•å‘ç‚¹è¿˜æœ‰ç‚¹å¤š---äº†è§£è¿™ä¸ªå¯ä»¥å¸®åŠ©ç†è§£è§£æ³•3ã€‚

`ç®—æ³•æµç¨‹:`
1. ç”³è¯·ä¸¤ä¸ªArrayListï¼Œ list1,list2ã€‚å°†æ ¹èŠ‚ç‚¹åŠ å…¥åˆ°list1ä¸­ã€‚
2. å¦‚æœlist2ä¸ºç©ºï¼Œ é‚£ä¹ˆä»å·¦å‘å³å¤„ç†list1çš„èŠ‚ç‚¹ã€‚ æ¯ä¸ªèŠ‚ç‚¹å·¦å³å­©å­çš„é¡ºåº(å¦‚æœå­˜åœ¨)åŠ å…¥list2ä¸­ã€‚
3. å¦‚æœlist1ä¸ºç©ºï¼Œ é‚£ä¹ˆä»å³å¾€å·¦å¤„ç†list2çš„èŠ‚ç‚¹ï¼Œ æ¯ä¸ªèŠ‚ç‚¹æŒ‰ç…§å³å­©å­å…ˆè¿›ï¼Œå·¦å­©å­åè¿›(å¦‚æœæœ‰)çš„é¡ºåºæ·»åŠ å…¥list1ä¸­ã€‚
4. äº¤æ›¿è¿›è¡Œ2ï¼Œ3ã€‚ç›´åˆ°ä¸¤ä¸ªArrayListéƒ½ä¸ºç©ºã€‚

`å‘ç‚¹:æ­¥éª¤2æ˜¯ä»å·¦å¾€å³çš„é¡ºåºï¼Œ èŠ‚ç‚¹å­©å­è¿˜æ˜¯å·¦ > å³çš„ä¼˜å…ˆçº§ã€‚
æ­¥éª¤3æ˜¯ä»å³å¾€å·¦çš„é¡ºåº, èŠ‚ç‚¹å­©å­æ˜¯å·¦  å³çš„ä¼˜å…ˆçº§ã€‚æ³¨æ„åŒºåˆ«ï¼è¿™ç§é¡ºåºå¤„ç†æ˜¯ä¸ºäº†ä¿è¯list1ä¸list2äº¤æ›¿ä¸”èƒ½é‡å¤è¿›è¡Œ(ä¸ç ´åä¸‹æ¬¡çš„é¡ºåº)ã€‚
`

`ä»£ç `:
```java
    // //æäº¤æ—¶ä¿®æ”¹å‡½æ•°å->zigzagLevelOrder
    public List<List<Integer>> zigzagLevelOrder2(TreeNode head) {
        var ans = new ArrayList<List<Integer>>();
        if (head != null) {
            //æ­¥éª¤ä¸€:ç”³è¯·ä¸¤ä¸ªlist, å¹¶åˆå§‹å¤„ç†list1
            ArrayList<TreeNode> list1 = new ArrayList<>();
            ArrayList<TreeNode> list2 = new ArrayList<>();
            list1.add(head);

            //æ­¥éª¤4: list1 ä¸ list2æ€»æœ‰ä¸€ä¸ªä¸ºç©ºã€‚äº¤æ›¿é‡å¤å¤„ç†
            while (!list1.isEmpty() || !list2.isEmpty()) {
                int size;
                List<Integer> list = new ArrayList<>();
                if (list2.isEmpty()) {
                    //æ­¥éª¤2:list2ä¸ºç©ºå°±å¤„ç†list1, ä»å·¦å¾€å³çš„é¡ºåº
                    //å¤´åˆ list1çš„èŠ‚ç‚¹å¹¶ä¸”å°†å…¶å­©å­æŒ‰å·¦å³é¡ºåºåŠ å…¥åˆ°list2ã€‚
                    size = list1.size();

                    while (size-- > 0) {
                        head = list1.removeFirst();
                        list.add(head.val);

                        if (head.left != null) {
                            list2.add(head.left);
                        }
                        if (head.right != null) {
                            list2.add(head.right);
                        }
                    }
                } else {

                    //æ­¥éª¤3:list1ä¸ºç©ºé‚£ä¹ˆå¤„ç†list2, ä»å·¦å¾€å³çš„é¡ºåº
                    //å°¾åˆ list1çš„èŠ‚ç‚¹å¹¶ä¸”å°†å…¶å­©å­æŒ‰å³->å·¦é¡ºåºåŠ å…¥åˆ°list1ã€‚
                    size = list2.size();

                    while (size-- > 0) {
                        head = list2.removeLast();
                        list.add(head.val);
                        if (head.right != null) {
                            list1.addFirst(head.right);
                        }

                        if (head.left != null) {
                            list1.addFirst(head.left);
                        }
                    }
                }
                ans.add(list);
            }
        }
        return ans;
    }

```
###### **`è§£æ³•3:`[`åŒç«¯é˜Ÿåˆ—`](https://www.youtube.com/watch?v=tSnF6C03joI&list=PLvKfL6GtwDxwuyrpAJfU3HTnPZl4WnraE&index=16)`ï¼ˆåŒå‘é“¾è¡¨ï¼‰`**
å¦‚æœä½ æ„Ÿå…´è¶£çœ‹äº†æœ¬é¢˜çš„è§£æ³•2, ä½ å¯èƒ½ä¼šéœ‡æƒŠæ€ä¹ˆç”¨`ArrayList`çš„å¤´æ’å¤´åˆ æ“ä½œï¼ˆæ—¶é—´å¤æ‚åº¦æœ€åæƒ…å†µæ˜¯$O(n)$ï¼‰ã€‚
è¿™ç§**é¢‘ç¹æ’å…¥åˆ é™¤**çš„æƒ…å†µåº”è¯¥ç”¨é“¾è¡¨å§ã€‚

æ­£ç¡®çš„ï¼Œ å¤´æ’å¤´åˆ å°¾æ’å°¾åˆ  `æ•ˆç‡æœ€é«˜çš„ç»“æ„->é“¾è¡¨`ã€‚
å¦‚æœä½ ç”¨å•é“¾è¡¨å®ç°è¿‡é˜Ÿåˆ—å’Œæ ˆï¼Œ å¯èƒ½è¿˜å¬è¯´è¿‡åä¸º`åŒç«¯é˜Ÿåˆ—`çš„æ•°æ®ç»“æ„ã€‚
æ•°æ®ç»“æ„éƒ½æ˜¯åŸºäºæ•°ç»„æˆ–è€…é“¾è¡¨å®ç°çš„ï¼Œ åŒç«¯é˜Ÿåˆ—æœ¬èº«å°±æ˜¯ä¸€ç§æŠ½è±¡ã€‚
**åŒç«¯é˜Ÿåˆ—:å¤´æ’å¤´åˆ å°¾æ’å°¾åˆ $O(1)$ã€‚**
Javaä¸­çš„åŒç«¯é˜Ÿåˆ—æ˜¯`Deque`æ¥å£ï¼Œ é“¾å¼ç»“æ„å®ç°ç±»æ˜¯`LinkedList`åŒå‘é“¾è¡¨ï¼Œ é¡ºåºç»“æ„å®ç°ç±»æ˜¯`ArrayDeque`å¾ªç¯é˜Ÿåˆ—å‡å¯ä»¥å……å½“åŒç«¯é˜Ÿåˆ—ã€‚*å¦å¤–ï¼Œæ‰‹å†™ä¸€ä¸ªå•é“¾è¡¨å……å½“åŒç«¯é˜Ÿåˆ—ï¼ˆç†Ÿæ‚‰å•é“¾è¡¨å®ç°è¿‡é˜Ÿåˆ—å’Œæ ˆï¼Œ è‡ªç„¶æ˜ç™½åŒç«¯é˜Ÿåˆ—å°±æ˜¯æ ˆ+é˜Ÿåˆ—çš„åˆä½“ï¼‰ï¼Œ æ•°ç»„å……å½“åŒç«¯é˜Ÿåˆ—(`åé¢çš„è§£æ³•4(æœ¬é¢˜æœ€ä¼˜è§£)`)ã€‚*

`ç®—æ³•æµç¨‹(å¤§è‡´åŒè§£æ³•2ï¼Œ ä¸è¿‡æ’å…¥åˆ é™¤é€Ÿåº¦æ›´å¿«):`
1. ç”³è¯·ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—`deque`,ï¼ˆJavaä¸­ç”¨`LinkedList`æˆ–è€…`ArrayDeque`ï¼‰ï¼Œ æ ¹èŠ‚ç‚¹å…¥é˜Ÿå¤„ç†ã€‚`åˆå§‹åŒ–ä¸€ä¸ªå¸ƒå°”å˜é‡reverse`ã€‚
2. reverseä¸ºfalse, ä»å·¦å¾€å³å¤„ç†ã€‚å³å·¦é˜Ÿå¤´å‡ºé˜Ÿï¼Œ å¹¶å°†å…¶å­©å­æŒ‰ç…§`å·¦å³`é¡ºåºä»å³é˜Ÿå¤´(å·¦é˜Ÿå°¾)å…¥é˜Ÿã€‚æ‰§è¡Œå®Œåè½¬reverse(true),æ‰§è¡Œæ­¥éª¤3ã€‚
3. reverseä¸ºtrue , ä»å³å¾€å·¦å¤„ç†ã€‚å³å³é˜Ÿå¤´å‡ºé˜Ÿï¼Œ å¹¶å°†å…¶å­©å­æŒ‰ç…§`å³å·¦`é¡ºåºä»å³é˜Ÿå¤´(å·¦é˜Ÿå°¾)å…¥é˜Ÿã€‚æ‰§è¡Œå®Œåè½¬reverse(false),æ‰§è¡Œæ­¥éª¤2ã€‚
4. æ­¥éª¤2ï¼Œ3äº¤æ›¿æ‰§è¡Œæ˜¯é€šè¿‡reverseå’Œåè½¬å®ç°ï¼Œ å¾ªç¯ç»“æŸæ¡ä»¶æ˜¯åŒç«¯é˜Ÿåˆ—ä¸ºç©ºã€‚


`ä»£ç `
```java
    // //æäº¤æ—¶ä¿®æ”¹å‡½æ•°å->zigzagLevelOrder
    public List<List<Integer>> zigzagLevelOrder3(TreeNode head){
        var ans = new ArrayList<List<Integer>>();
        if (head != null) {
            //ç”³è¯·ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œ æ ¹èŠ‚ç‚¹ä»åå…¥é˜Ÿ
            Deque<TreeNode> deque = new LinkedList<>();
            deque.offerLast(head);
            // reverse:false -> ä»å·¦å‘å³: deque
            // reverse:true -> ä»å³å¾€å·¦: deque
            boolean reverse = false;
            while(!deque.isEmpty()){
                int size = deque.size();
                List<Integer> list = new ArrayList<>();
                //æ­¥éª¤2: reverseä¸ºfalseï¼Œ ä»å·¦å‘å³æ‰§è¡Œã€‚
                if(!reverse){
                    while(size-- > 0) {
                        //å·¦é˜Ÿå¤´å‡ºé˜Ÿ
                        head = deque.pollFirst();
                        list.add(head.val);
                        //å…ˆå·¦åå³: å³é˜Ÿå¤´å…¥
                        if (head.left != null) {
                            deque.offerLast(head.left);
                        }
                        if (head.right != null) {
                            deque.offerLast(head.right);
                        }
                    }
                }
                else{
                    //æ­¥éª¤3: reverseä¸ºtrueï¼Œ ä»å³å‘å·¦æ‰§è¡Œã€‚
                    while(size-- > 0) {
                        //å³é˜Ÿå¤´å‡ºé˜Ÿ
                        head = deque.pollLast();
                        list.add(head.val);
                        //å…ˆå³åå·¦ï¼šå·¦é˜Ÿå¤´å…¥
                        if (head.right != null) {
                            deque.offerFirst(head.right);
                        }
                        if (head.left != null) {
                            deque.offerFirst(head.left);
                        }
                    }
                }
                ans.add(list);
                //æ­¥éª¤2ï¼Œ3äº¤æ›¿æ‰§è¡Œï¼Œ å› æ­¤è¦åè½¬reverseã€‚ ï¼reverseå³å¯ã€‚
                reverse = !reverse;
            }
        }
        return ans;
    }
```

###### **`è§£æ³•4: é™æ€æ•°ç»„åŒç«¯é˜Ÿåˆ—ï¼ˆæœ¬é¢˜æœ€ä¼˜è§£ï¼‰`**
äº†è§£è§£æ³•4éœ€è¦æœ¬é¢˜è§£æ³•3çš„ç®—æ³•æµç¨‹å’Œ[å›ºå®šæ•°ç»„å®ç°åŒç«¯é˜Ÿåˆ—](https://www.youtube.com/watch?v=tSnF6C03joI&list=PLvKfL6GtwDxwuyrpAJfU3HTnPZl4WnraE&index=16)ã€‚

`ä»£ç `:
```java
    //leetcodeä¿®æ”¹æ•°æ®é‡ï¼Œ ä»…ä¿®æ”¹ä¸€ä¸‹MAXå³å¯
    public static int MAX = 2001;
    //å…¨å±€é™æ€æ•°ç»„å®ç°åŒç«¯é˜Ÿåˆ—
    public static TreeNode[] queue = new TreeNode[MAX];
    public static int l,r;
    //æäº¤æ—¶ä¿®æ”¹å‡½æ•°å->zigzagLevelOrder
    public List<List<Integer>> zigzagLevelOrder4(TreeNode head){
        List<List<Integer>> ans = new ArrayList<>();
        if(head != null){
            //é‡ç½®l,r
            l = r = 0;
            boolean reverse = false;
            queue[r++] = head;
            while(l != r){
                int size = r - l;
                ArrayList<Integer> list = new ArrayList<>();
                
                //reverse == false. å·¦->å³ï¼Œ i [l,r-1]é¡ºåºï¼Œ j = 1ã€‚æ”¶é›†sizeä¸ªã€‚
                //reverse == true. å³->å·¦ï¼Œ i [r-1 - > l] , j = -1ã€‚æ”¶é›†sizeä¸ªã€‚
                //ä¸Šä¸¤æ­¥æ˜¯å¯¹ç§°è¿‡ç¨‹ï¼Œ ä¸€ä¸ªreverseåŠ ä¸‰ç›®ä¼˜é›…è§£å†³ã€‚
                for(int i = reverse ? r - 1 : l,j = reverse ? -1 : 1, k = 0;k < size; i += j, k++){
                    TreeNode cur = queue[i];
                    list.add(cur.val);
                }

                for (int i = 0; i < size; i++) {
                    TreeNode cur = queue[l++];
                    if (cur.left != null) {
                        queue[r++] = cur.left;
                    }
                    if (cur.right != null) {
                        queue[r++] = cur.right;
                    }
                }

                ans.add(list);
                //åè½¬
                reverse = !reverse;
            }

        }
        return ans;
    }
```
:::

:::note[Class02äºŒå‰æ ‘OJé¢˜ç»ƒä¹ ]

#### **Coding[åŸºç¡€&è¿›é˜¶]äºŒå‰æ ‘ç»å…¸é¢˜ç»ƒä¹ ** 

##### **010 [äºŒå‰æ ‘çš„æœ€å¤§å®½åº¦](https://leetcode.cn/problems/maximum-width-of-binary-tree/description/)**
`å‰ç½®çŸ¥è¯†:äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨ç»“æ„ + 008ä¼˜åŒ–ç‰ˆæœ¬çš„å±‚åºéå† + å®Œå…¨äºŒå‰æ ‘çˆ¶èŠ‚ç‚¹å­©å­èŠ‚ç‚¹çš„ä¸‹æ ‡å…³ç³»ã€‚`

![s](./blogdemo/äºŒå‰æ ‘ä¸“é¢˜åšå®¢å›¾ç‰‡/maximum-width-of-binary-tree-v3.jpg)
å…ˆè¯´æ˜ä»€ä¹ˆæ˜¯æ¯å±‚çš„å®½åº¦ï¼Ÿ
äºŒå‰æ ‘çš„å®½åº¦æ¦‚å¿µæ˜¯åŸºäºå±‚çš„ã€‚
ä»å½“å‰å±‚çš„ç¬¬ä¸€ä¸ªéç©ºèŠ‚ç‚¹åˆ°æœ€åä¸€ä¸ªéç©ºèŠ‚ç‚¹çš„è·ç¦»ï¼ˆåŒ…æ‹¬ä¸¤ä¸ªèŠ‚ç‚¹æœ¬èº«ï¼‰ã€‚æ¯”å¦‚ï¼Œå¦‚å›¾ç¬¬ä¸€å±‚åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹`1`, å®½åº¦ä¸º1ã€‚; ç¬¬äºŒå±‚èŠ‚ç‚¹`3->2`,å®½åº¦ä¸º2ã€‚
ç¬¬ä¸‰å±‚èŠ‚ç‚¹5->9, å®½åº¦ä¸æ˜¯2ï¼Œ æƒ³è±¡æˆå®Œå…¨äºŒå‰æ ‘ï¼Œ ä¸­é—´çš„ç©ºéš™æœ‰nullæ›¿ä»£äº†ï¼Œ å®é™…ä¸Šåº”è¯¥æ˜¯`5->null->null->9`ï¼Œå®½åº¦ä¸º4ï¼ˆä»å½“å‰å±‚çš„é¦–ä¸ªéç©ºèŠ‚ç‚¹åˆ°æœ€åä¸€ä¸ªéç©ºèŠ‚ç‚¹ï¼‰;åŒç†ï¼Œ ç¬¬4å±‚åº”è¯¥æ˜¯`6->null->null->null->null->null->7`ï¼Œ å°½ç®¡ä¸Šä¸€å±‚ä½ç½®å¯èƒ½æ˜¯ç©ºèŠ‚ç‚¹äº†ï¼Œ ä½†è®°ä½ä¸æˆä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘(ç”¨nullè¡¥å‡ºæ¥)ã€‚ç¬¬å››å±‚å®½åº¦åº”è¯¥æ˜¯7ã€‚

é‚£ä¹ˆæœ€å¤§å®½åº¦å°±æ˜¯æ¯å±‚çš„å®½åº¦æ¯”è¾ƒå‡ºæœ€å¤§å€¼çš„ç»“æœã€‚

å¥½ï¼Œ ç°åœ¨ä½ åº”è¯¥æ˜ç™½äº†ï¼Œ è¿™é‡Œè¦åšå±‚åºéå†(å¹¿åº¦ä¼˜å…ˆéå†)ã€‚
é‚£ä¹ˆå¦‚ä½•å¿«é€Ÿè·å–æ¯å±‚å®½åº¦ï¼Ÿéè¦éå†ç©ºèŠ‚ç‚¹æŒ‰ç…§ä¸Šé¢çš„è§„åˆ™ç®—å‡ºæ¥å—ï¼Ÿ
`ç­”æ¡ˆæ˜¯ç”¨ä¸ç€ï¼Œ å¯¹æ¯ä¸ªèŠ‚ç‚¹åŒ…æ‹¬ç©ºèŠ‚ç‚¹éƒ½æŒ‰å±‚ä»å·¦å¾€å³ä»ä¸Šåˆ°ä¸‹è¿›è¡Œç¼–å·å°±å¥½äº†ã€‚`

è¿˜æ˜¯ä»¥ä¸Šå›¾ä¸¾ä¾‹
![1](./blogdemo/äºŒå‰æ ‘ä¸“é¢˜åšå®¢å›¾ç‰‡/demo1.png)
ç¬¬å››å±‚å®½åº¦ç¼–å·ä¸º13çš„æœ€åä¸€ä¸ªéç©ºèŠ‚ç‚¹ - ç¼–å·ä¸º7çš„éç©ºèŠ‚ç‚¹ + 1å°±æ˜¯è¯¥å±‚çš„å®½åº¦ã€‚
æœ‰ä¸€ç§ç»“æ„å¤©ç„¶å°±é€‚åˆç¼–å·ï¼Œ å°±æ˜¯æ•°ç»„ã€‚ è¿™é‡Œå°±æ˜¯ç”¨æ•°ç»„å®ç°äºŒå‰æ ‘çš„è¡¨ç¤ºï¼Œ åœ¨æ•°æ®ç»“æ„`å †ä¸ä¼˜å…ˆçº§é˜Ÿåˆ—`ä¸­å°±æ˜¯è¿™ç§å®ç°ã€‚

###### `å”¯ä¸€è§£æ³•: æ•°ç»„+æ•°ç»„å……å½“é˜Ÿåˆ—`

ç®—æ³•æµç¨‹:
1. ç”³è¯·ä¸¤ä¸ªé™æ€æ•°ç»„`TreeNode`èŠ‚ç‚¹æ•°ç»„å’Œ`int[] iq`ç¼–å·æ•°ç»„ã€‚é‡ç½®l,rã€‚æ ¹èŠ‚ç‚¹å…¥é˜Ÿå’Œå…¥ç¼–å·ã€‚
2. å¤„ç†å½“å‰å±‚ï¼Œ è·å–å½“å‰å±‚çš„é•¿åº¦ï¼Œ é˜Ÿåˆ—å§‹ç»ˆç»´æŒå½“å‰å±‚æœ€å·¦å³çš„éç©ºèŠ‚ç‚¹ï¼Œ `iq[r - 1] - iq[l] + 1`å¯ä»¥è½»æ˜“å¾—åˆ°å½“å‰å±‚çš„å®½åº¦ã€‚
3. ç»§ç»­å¤„ç†å½“å‰å±‚èŠ‚ç‚¹ï¼Œ ä¾æ¬¡å‡ºé˜Ÿå¹¶è·å–å…¶ç¼–å·ï¼Œ å°†å…¶å·¦å³å­©å­å…¥é˜Ÿ(å¦‚æœå­˜åœ¨), åŒæ—¶æ›´æ–°å…¶ç¼–å·ä¿¡æ¯ã€‚
4. é‡å¤2ï¼Œ3ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º`l==r`ã€‚

`ä»£ç `:
```java
    //æäº¤ä»¥ä¸‹æ–¹æ³•éœ€æ³¨æ„
    //å¦‚æœæµ‹è¯•æ•°æ®é‡è¿‡å¤§ï¼Œ éœ€è¦ä¿®æ”¹MAX
    //ç”¨æ¯æ¬¡å¤„ç†çš„ä¸€å±‚ä¼˜åŒ–bfså°±éå¸¸å®¹æ˜“å®ç°ã€‚
    public static int MAX = 3001;
    public static TreeNode[] nq = new TreeNode[MAX];
    public static int[] iq = new int[MAX];
    public static int l,r;
    public static int widthOfBinaryTree(TreeNode head){
        if(head == null){
            return 0;
        }
        //ansåˆå§‹ä¸º1.
        int ans = 1;
        //é‡ç½®l,r, é˜²æ­¢è¢«ä¸Šä¸€æ¬¡æ±¡æŸ“æ•°æ®
        l = r = 0;
        nq[r] = head;
        iq[r++] = 1;
        while(l != r){

            //è·å–å½“å‰é˜Ÿåˆ—é•¿åº¦
            int size = r - l;
            //æ›´æ–° ans , é˜Ÿåˆ—ç»´æŒçš„éƒ½æ˜¯éç©ºèŠ‚ç‚¹ã€‚ iq[r-1] - iq[l] + 1ï¼šå½“å‰å±‚ç¼–å·ã€‚
            ans = Math.max(ans, iq[r - 1] - iq[l] + 1);

            //å¾ªç¯å¯¹å½“å‰å±‚è¿›è¡Œå¤„ç†
            //å’Œä¼˜åŒ–ç‰ˆæœ¬çš„bfså¤§åŒå°å¼‚ï¼Œ lä¹Ÿç»´æŒidçš„æœ‰æ•ˆæ•°æ®ã€‚
            while(size-- > 0){
                head = nq[l];
                int id = iq[l++];

                if(head.left != null){
                    nq[r] = head.left;
                    iq[r++] = id << 1;
                }
                if(head.right != null){
                    nq[r] = head.right;
                    iq[r++] = (id << 1) + 1;
                }
            }
        }
        return ans;
    }
```

##### **011 [äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)**
äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦å°±æ˜¯å®ƒçš„é«˜åº¦ã€‚
ä»é€’å½’è§’åº¦äºŒå‰æ ‘çš„æœ€å¤§çš„æ·±åº¦å–å†³äº `æ ¹èŠ‚ç‚¹çš„ç®—ä¸€å±‚æ·±åº¦ + å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦`ã€‚å¯¹äºå­æ ‘ä¹Ÿæ»¡è¶³è¿™æ¡åŸåˆ™ã€‚

é€’å½’å†™æ³•è¦å¤„ç†åŸºç¡€æ¡ä»¶: å½“é€’å½’åˆ°ç©ºèŠ‚ç‚¹æ—¶åº”è¯¥è¿”å›0ã€‚

`ä»£ç `
```java
    //äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€‚
    public static int maxDepth(TreeNode head){
        return head == null?0: Math.max(maxDepth(head.left), maxDepth(head.right)) + 1;
    }
```

##### **012 [äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)**

###### **è§£æ³•1:é€’å½’(æ·±åº¦ä¼˜å…ˆéå†)**
äºŒå‰æ ‘é—®é¢˜ éå† + é€’å½’ å¾€å¾€æ¯”è¾ƒç›´è§‚ã€‚

æ‰¾åˆ°æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°è¾¾å¶å­èŠ‚ç‚¹çš„æ·±åº¦ï¼Œ ä¾æ¬¡æ¯”è¾ƒå‡ºæœ€å°å€¼ã€‚ æœ¬é¢˜çš„æ·±åº¦æ˜¯æŒ‰ç…§`èŠ‚ç‚¹æ•°é‡`çš„æ ‡å‡†ã€‚

`ç®—æ³•æµç¨‹:`
1. å…ˆè®¨è®ºæ˜¯å¦ä¸ºç©ºæ ‘ï¼Œ å¦‚ä¸ºç©ºæ ‘è¿”å›0,å¦åˆ™æ‰§è¡Œæ­¥éª¤2ã€‚
2. è®¨è®ºè¯¥èŠ‚ç‚¹æ˜¯å¦ä¸ºå¶å­èŠ‚ç‚¹ï¼Œ è‹¥æ»¡è¶³è¿”å›1ï¼Œ å¦åˆ™æ‰§è¡Œæ­¥éª¤3ã€‚
3. é€’å½’åœ°è®¡ç®—å¹¶æ¯”è¾ƒå·¦å³å­æ ‘çš„æœ€å°æ·±åº¦ã€‚ å¦‚æœå·¦å­æ ‘æˆ–è€…å³å­æ ‘å…¶ä¸­æœ‰ä¸€ä¸ºç©ºï¼Œ é‚£ä¹ˆä¸ç”¨æ¯”è¾ƒã€‚ å°†æœ€åå‰©ä¸‹æˆ–è€…æ¯”è¾ƒçš„ç»“æœ + 1ã€‚é€’å½’ç»“æŸï¼Œ æœ€ç»ˆç»“æœå°±æ˜¯æ•´æ£µæ ‘çš„æœ€å°æ·±åº¦ã€‚

`ä»£ç `:
```java
    //äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ã€‚
    // æµ‹è¯•é“¾æ¥ : https://leetcode.cn/problems/minimum-depth-of-binary-tree/
    //æäº¤æ—¶ä¿®æ”¹å‡½æ•°åå’Œå†…éƒ¨é€’å½’å‡½æ•°åä¿æŒä¸€è‡´ -> minDepth1
    public static int minDepth1(TreeNode head){
        if(head == null){
            //å½“å‰æ ‘ä¸ºç©ºæ ‘ï¼Œç›´æ¥è¿”å›
            return 0;
        }
        //å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œ é‚£ä¹ˆæä¾›ä¸€å±‚æ·±åº¦ã€‚
        if(head.left == null && head.right == null) {
            return 1;
        }
        //å·¦å­æ ‘çš„æœ€å°æ·±åº¦ åˆå§‹ä¸ºç³»ç»Ÿæœ€å¤§
        int lDepth = Integer.MAX_VALUE;
        //å³å­æ ‘çš„æœ€å°æ·±åº¦ åˆå§‹ä¸ºç³»ç»Ÿæœ€å¤§
        int rDepth = Integer.MAX_VALUE;

        //å¦‚æœå½“å‰èŠ‚ç‚¹å­˜åœ¨å·¦å­æ ‘ï¼Œ é‚£ä¹ˆé€’å½’è°ƒç”¨ã€‚
        if(head.left != null){
            lDepth = minDepth1(head.left);
        }
        //å¦‚æœå½“å‰èŠ‚ç‚¹å­˜åœ¨å³å­æ ‘ï¼Œ é‚£ä¹ˆé€’å½’è°ƒç”¨
        if(head.right != null){
            rDepth = minDepth1(head.right);
        }
        //ç»“ç®—ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å°æ·±åº¦ã€‚
        //æ¯”è¾ƒå·¦å³å­æ ‘çš„æœ€å°çš„æ·±åº¦å‡ºæœ€å°å€¼ + 1ã€‚
        return Math.min(lDepth, rDepth) + 1;
    }
```

###### **è§£æ³•2:ä¼˜åŒ–ç‰ˆå±‚åºéå†ï¼ˆå¹¿åº¦ä¼˜å…ˆéå†ï¼‰**
å‰ç½®çŸ¥è¯†:` 008å±‚åºéå†(ä¼˜åŒ–ç‰ˆbfs)`
æœ€å°æ·±åº¦å°±æ˜¯æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹ä¹‹é—´çš„æ•°é‡ã€‚ 
è§£æ³•1çš„é€’å½’æ–¹æ³•å¥½æ¯”, å¾€æ·±å¤„æ‰¾å‡ºæ¯ä¸ªèŠ‚ç‚¹ä¾æ¬¡æ¯”è¾ƒå‡ºç»“æœã€‚
æœ‰æ— é«˜æ•ˆçš„è§£æ³•ï¼Ÿä¸ç”¨æšä¸¾æ‰€æœ‰å¶å­èŠ‚ç‚¹ã€‚
å®½åº¦ä¼˜å…ˆéå†æ˜¯æŒ‰å±‚éå†ï¼Œ é‚£ä¹ˆå½“å®ƒæ‰¾å¶å­èŠ‚ç‚¹å¾ˆå¿«ã€‚

`ç®—æ³•æµç¨‹:`
1. ä¼˜åŒ–ç‰ˆæœ¬çš„bfs + å¯¹å¶å­èŠ‚ç‚¹çš„åˆ¤æ–­ + ansè®°å½•å½“å‰å±‚æ•°(ä»ä¸€å¼€å§‹è®¡æ•°)ã€‚

è¿™é‡Œä»¥å›ºå®šæ•°ç»„å®ç°é˜Ÿåˆ—å¯ä»¥åšåˆ°100%å‡»è´¥ç‡ã€‚
```java
class Solution {
        //---------------------------è§£æ³•2:äºŒå‰æ ‘çš„æœ€å°æ·±åº¦------------------
        //leetcodeæäº¤ä¿®æ”¹æ•°æ®é‡è®°å¾—æ›´æ”¹
        //æäº¤æ—¶ä¿®æ”¹å‡½æ•°å->minDepth
        public static int MAX = 10001;
        public static TreeNode[] queue = new TreeNode[MAX];
        public static int l,r;
        public static int minDepth2(TreeNode head){
            if(head == null) return 0;//ç©ºæ ‘

            l = r = 0;//é‡ç½®l,r =>ç­‰ä»·äºæ¸…ç©ºé˜Ÿåˆ—
            queue[r++] = head;
            //åˆå§‹åªæœ‰æ ¹èŠ‚ç‚¹ï¼Œ æ‰€ä»¥ä¸º1
            int ans = 1;
            outerloop:
            while(l != r) {
                //è·å–æ•°ç»„å¤§å°
                int size = r - l;

                //ä¼˜åŒ–ç‰ˆbfsï¼Œ æŒ‰å±‚å¤„ç†ã€‚
                while (size-- > 0) {
                    head = queue[l++];
                    //å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œç”±å®½åº¦ä¼˜å…ˆéå†çš„ç‰¹ç‚¹ï¼Œ å¿…å®šé‡ä¸Šäº†ç¬¬ä¸€ä¸ªå¶èŠ‚ç‚¹ï¼Œ å¿…å®šæ˜¯æœ€å°çš„æ·±åº¦
                    if (head.left == null && head.right == null) {
                        break outerloop;
                    }
                    //å¦‚æœå½“å‰èŠ‚ç‚¹å­˜åœ¨å·¦å­æ ‘ï¼Œ é‚£ä¹ˆå…¥é˜Ÿã€‚
                    if (head.left != null) {
                        queue[r++] = head.left;
                    }
                    //å¦‚æœå½“å‰èŠ‚ç‚¹
                    if (head.right != null) {
                        queue[r++] = head.right;
                    }
                }
                //å¤„ç†å®Œä¸€å±‚å°±++, æ„å‘³ç€æœ€å°æ·±åº¦ä¸åœ¨é‚£ä¸€å±‚
                ans++;
            }

            //å‘ç°äº†ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œ break å¸¦æ ‡ç­¾ è·³å‡ºå¤šå±‚å¾ªç¯è¿”å›ans!!!
            return ans;
        }
    }
```

##### **013 å…ˆåºéå†åºåˆ—åŒ–å’Œååºåˆ—åŒ–**
å†…å­˜ä¸­äºŒå‰æ ‘ç»“æ„å¦‚ä½•å¾—ä»¥ä¿å­˜ã€‚ æˆ‘ä»¬çŸ¥é“å†…å­˜æ–­ç”µ(æ²¡æœ‰ä»»ä½•æœåŠ¡ä¼šæ°¸è¿œè¿›è¡Œ)ä¼šä¸¢æ•°æ®ã€‚
ç¡¬ç›˜å¯ä»¥æŒä¹…åŒ–åœ°ä¿å­˜æ–‡ä»¶ã€‚ å¦‚ä½•å°†äºŒå‰æ ‘ä¿å­˜åœ¨ç¡¬ç›˜ä¸Šå‘¢?
æ–‡ä»¶æ˜¯æ–‡æœ¬å†…å®¹ï¼Œ å°±æ˜¯ä¸€å †å­—ç¬¦ä¸²ã€‚
åºåˆ—åŒ–æœ¬è´¨æ˜¯ä¸€ç§æ˜ å°„å…³ç³»ã€‚åªæœ‰å°†äºŒå‰æ ‘æ˜ å°„å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ å¹¶ä¸”ä¿è¯å­—ç¬¦ä¸²èƒ½åœ¨å†…å­˜ä¸­è°ƒç”¨å‡½æ•°è¿˜åŸå‡ºè¿™ä¸ªäºŒå‰æ ‘ï¼Œ å°±å¯ä»¥è¯´æ˜¯é—´æ¥ä¿å­˜äº†è¿™é¢—äºŒå‰æ ‘ã€‚
`äºŒå‰æ ‘->å­—ç¬¦ä¸²`:ç§°ä½œäºŒå‰æ ‘çš„åºåˆ—åŒ–ã€‚
`å­—ç¬¦ä¸²->äºŒå‰æ ‘`:ç§°ä½œäºŒå‰æ ‘çš„ååºåˆ—åŒ–ã€‚

`013`æ˜¯æ ¹æ®å…ˆåºéå†æ„å»ºçš„ã€‚
åºåˆ—åŒ–ååºåˆ—åŒ–å¯ä»¥æ ¹æ®ååºéå†å’Œå±‚åºéå†æ„å»ºå¯¹åº”çš„å­—ç¬¦ä¸²ã€‚
**ä¸­åºéå†ä¸è¡Œï¼Œ åé¢ä¼šä¸¾ä¾‹è¯´æ˜ã€‚**

å¦‚ä½•å”¯ä¸€èƒ½ä¿è¯å­—ç¬¦ä¸²å’ŒäºŒå‰æ ‘ç»“æ„å¯¹åº”å”¯ä¸€å‘¢?
```
       A
      / \
     B   C
    / \   \
   D   E   F

```

`å…ˆåºåºåˆ—åŒ–ç»“æœ`:
`A,B,D,#,#,E,#,#,C,#,F,#,`

ç”¨,ä½œä¸ºèŠ‚ç‚¹åˆ†éš”ç¬¦ï¼›ç”¨#æ›¿ä»£nullï¼ˆæˆ–ç©ºèŠ‚ç‚¹ï¼‰ã€‚

`ä»£ç `:
```java
//æ³¨æ„ä¿®æ”¹ç±»å->Solution
//æµ‹è¯•é“¾æ¥: https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/
public class Coding006_PreorderSerializeAndDeserialize {
    //ä¸è¦æäº¤è¿™ä¸ªç±»
     public static class TreeNode {
         int val;
         TreeNode left;
         TreeNode right;
         TreeNode(int x) { val = x; }
     }

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
         //åˆ›å»ºä¸€ä¸ªå¯å˜å­—ç¬¦ä¸²ç±»StringBuilderç±»
         // å­—ç¬¦ä¸²é«˜æ•ˆå¢åŠ å…ƒç´ ã€‚
         StringBuilder builder = new StringBuilder();
         //è¾…åŠ©è°ƒç”¨
         f(root, builder);
         return builder.toString();//è½¬String
    }
    //
    public void f(TreeNode root, StringBuilder builder){
         if(root == null){
             builder.append("#,");
         }
         else {
             //é“¾å¼è°ƒç”¨
             builder.append(root.val).append(",");
             f(root.left, builder);
             f(root.right, builder);
         }
    }
    //å…¨å±€å˜é‡è¿½è¸ªå½“å‰å­—ç¬¦
    public static int cnt = 0;
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //æ ¹æ®åˆ†å‰²ç¬¦","åˆ‡å‰²å­—ç¬¦ä¸² ->å­—ç¬¦ä¸²æ•°ç»„ã€‚
        String[] vals = data.split(",");
        cnt = 0;
        return g(vals);//è°ƒç”¨è¾…åŠ©æ–¹æ³•
    }

    public TreeNode g(String[] vals){
        //æå–å½“å‰å­—ç¬¦ä¸²
        String cur = vals[cnt++];
        if(cur.equals("#")){
            return null;
        }
        //é€’å½’: ç”Ÿæˆå½“å‰èŠ‚ç‚¹ + å·¦å­æ ‘è¿æ¥é€’å½’ + å³å­æ ‘è¿æ¥é€’å½’ã€‚
        TreeNode head = new TreeNode(Integer.parseInt(cur));
        head.left = g(vals);
        head.right = g(vals);
        return head;//è¿”å›æœ€ç»ˆç»“æœã€‚
    }
}

```

##### **014: ååºéå†åºåˆ—åŒ–å’Œååºåˆ—åŒ–**
å‰ç½®:`013`å…ˆåºéå†åºåˆ—åŒ–å’Œååºåˆ—åŒ–
åªéœ€è¦åœ¨013åŸºç¡€ä¸Šä¿®æ”¹ä¸€äº›å†…å®¹ï¼Œ å°±å¯ä»¥å¾—åˆ°ååºåˆ—åŒ–çš„ä»£ç äº†ã€‚
**åºåˆ—åŒ–è¿‡ç¨‹: é€’å½’æ„å»ºå­—ç¬¦ä¸²çš„è¿‡ç¨‹æ”¹æˆååºé¡ºåºã€‚
ååºåˆ—åŒ–è¿‡ç¨‹çš„æ ¹èŠ‚ç‚¹åº”è¯¥åˆ‡å‰²åå­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªä½ç½®ï¼Œ ç„¶åæŒ‰ç…§å³å·¦é¡ºåºå¤åŸæ ‘å³å¯ã€‚**

```java
////æ³¨æ„ä¿®æ”¹ç±»å->Solution
// æµ‹è¯•é“¾æ¥ : https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/
public class Coding007_PostorderSerializeAndDeserialize {
    //ä¸è¦æäº¤è¿™ä¸ªç±»
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        //åˆ›å»ºä¸€ä¸ªå¯å˜å­—ç¬¦ä¸²ç±»StringBuilderç±»
        // å­—ç¬¦ä¸²é«˜æ•ˆå¢åŠ å…ƒç´ ã€‚
        StringBuilder builder = new StringBuilder();
        //è¾…åŠ©è°ƒç”¨
        f(root, builder);
        return builder.toString();//è½¬String
    }
    //
    public void f(TreeNode root, StringBuilder builder){
        if(root == null){
            builder.append("#,");
        }
        else {
            f(root.left, builder);
            f(root.right, builder);
            builder.append(root.val).append(",");
        }
    }
    //å…¨å±€å˜é‡è¿½è¸ªå½“å‰å­—ç¬¦
    public static int cnt = 0;
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //æ ¹æ®åˆ†å‰²ç¬¦","åˆ‡å‰²å­—ç¬¦ä¸² ->å­—ç¬¦ä¸²æ•°ç»„ã€‚
        String[] vals = data.split(",");
        cnt = vals.length-1;
        return g(vals);//è°ƒç”¨è¾…åŠ©æ–¹æ³•
    }

    public TreeNode g(String[] vals){
        //æå–å½“å‰å­—ç¬¦ä¸²
        String cur = vals[cnt--];
        if(cur.equals("#")){
            return null;
        }
        TreeNode head = new TreeNode(Integer.parseInt(cur));
        head.right = g(vals);
        head.left = g(vals);
        return head;
    }
}
```

##### **015: å±‚åºéå†åºåˆ—åŒ–å’Œååºåˆ—åŒ–**
å‰ç½®:
`013`å…ˆåºéå†åºåˆ—åŒ–å’Œååºåˆ—åŒ–, äº†è§£åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„æ¦‚å¿µå³å¯ã€‚
`008ç»å…¸å±‚åºéå†`

çœ‹è¿‡ä»¥ä¸Šå‰ç½®ï¼Œ å¯ä»¥ç›´æ¥é˜…è¯»`ä»£ç `éƒ¨åˆ†å³å¯
```java
//äºŒå‰æ ‘çš„å±‚åºåºåˆ—åŒ–å’Œååºåˆ—åŒ–
public class Coding008_LevelorderSerializeAndDeserialize {
    //ä¸è¦æäº¤è¿™ä¸ªç±»
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int v) {
            val = v;
        }
    }
    //æäº¤è¿™ä¸ªç±»1
    public class Codec {

        public static int MAX = 10001;
        public static TreeNode[] queue = new TreeNode[MAX];
        public static int l,r;

        public String serialize(TreeNode root){
            StringBuilder builder = new StringBuilder();
            if(root != null){
                builder.append(root.val).append(",");
                l = r = 0;
                queue[r++] = root;
                while(l != r){
                    //è¿™é‡Œå¤ç”¨rootã€‚
                    root = queue[l++];
                    //ç»å…¸çš„bfsæ“ä½œå³å¯ã€‚ åªéœ€æ³¨æ„ï¼Œ å¦‚æœå­©å­ä¸ºç©ºåº”è¯¥ä»¥"#,"çš„å½¢å¼å­˜å…¥ã€‚
                    if(root.left != null){
                        queue[r++] = root.left;
                        builder.append(root.left.val).append(",");
                    }
                    else{
                        builder.append("#").append(",");
                    }

                    if(root.right != null){
                        queue[r++] = root.right;
                        builder.append(root.right.val).append(",");
                    }
                    else{
                        builder.append("#").append(",");
                    }
                }
            }
            return builder.toString();
        }

        /**
         * 
         * @param val å­—ç¬¦ä¸²
         * @return æ ¹æ®å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©ºä¸²è¿”å›èŠ‚ç‚¹ã€‚
         */
        private static TreeNode generate(String val){
            return val.equals("#") ? null : new TreeNode(Integer.parseInt(val));
        }
        public TreeNode deserialize(String data) {
            if(data.isEmpty()){
                return null;
            }
            //æ ¹æ®åˆ†å‰²ç¬¦","åˆ‡å‰²å­—ç¬¦ä¸²
            String[] vals = data.split(",");
            int cnt = 0;//è®°å½•å½“å‰å­—ç¬¦ä¸²æ•°ç»„çš„æœ‰æ•ˆå€¼
            l = r = 0;//é‡ç½®
            TreeNode root = generate(vals[cnt++]);
            queue[r++] = root;
            while(l != r){
                //æŒ‰é¡ºåºæŒ¨ä¸ªå¤„ç†
                TreeNode cur = queue[l++];
                
                //è¿æ¥å·¦å³å­©å­
                cur.left = generate(vals[cnt++]);
                cur.right = generate(vals[cnt++]);
                
                //æ ¹æ®curçš„å·¦å³å­©å­æ˜¯å¦ä¸ºç©ºå†³å®šå…¥é˜Ÿã€‚
                if(cur.left != null){
                    queue[r++] = cur.left;
                }
                if(cur.right != null){
                    queue[r++] = cur.right;
                }
            }
            return root;
        }
    }
}

```

##### **016 å…ˆåºæ•°ç»„å’Œä¸­åºæ•°ç»„æ„é€ äºŒå‰æ ‘**
![alt text](image.png)
>Input: 
`preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]`
`Output: [3,9,20,null,null,15,7]`

å€ŸåŠ©leetcodeçš„ç¬¬ä¸€ç»„æµ‹è¯•æ•°æ®åˆ†æï¼›
**å‰ç½®:å…ˆåºéå†å’Œä¸­åºéå†ç»“åˆ**
å…ˆåºéå†å¯ä»¥ç¡®å®šæ•´æ£µæ ‘åŠå…¶å­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
ä¸­åºéå†å¯ä»¥ç»“åˆå…ˆåºéå†çš„æ ¹èŠ‚ç‚¹åˆ†å‡ºå“ªäº›èŠ‚ç‚¹å„è‡ªå±äºå·¦å³å­æ ‘å“ªä¸€æ”¯ï¼Ÿ
ç„¶åé€’å½’åœ°è§£å†³å­æ ‘ï¼Œ ä¹Ÿæ˜¯ç›¸åŒçš„æ­¥éª¤ã€‚

`æ³¨æ„ï¼›å…ˆåºå’Œä¸­åºæ•°ç»„ + æ— é‡å¤å€¼ -> å”¯ä¸€ç¡®å®šçš„äºŒå‰æ ‘ç»“æ„`ï¼Œ  å¦‚æœæ•°ç»„ä¸­æœ‰é‡å¤å€¼åˆ™ç»“æœä¸å”¯ä¸€ã€‚
`è¯•ç€åˆ†æ:`
1. preorderçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹3ï¼Œ æ ¹æ®è¯¥èŠ‚ç‚¹çš„å€¼åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ä¸­åˆ’åˆ†åŒºé—´ã€‚
2. 3å·¦è¾¹æ˜¯[9], å³è¾¹æ˜¯[15,20,7]ã€‚
3. é€’å½’åœ°è§£å†³; 9å·²ç»æ˜¯å•ç‹¬çš„èŠ‚ç‚¹äº†ç›´æ¥è¿”å›ã€‚ ä¸­åºåŒºé—´åœ¨[15,20,7]å¯¹åº”å…ˆåºåŒºé—´[20,15,7]çš„ä½ç½®ã€‚
4. è¿˜æ˜¯æ ¹æ®å…ˆåºåŒºé—´ç¡®å®šå­æ ‘çš„æ ¹èŠ‚ç‚¹20ï¼Œ åœ¨ä¸­åºåˆ’åˆ†äº†[15], [20]ã€‚ ç”±äºå„è‡ªåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹é‚£ä¹ˆç›´æ¥è¿”å›å³å¯ã€‚

**ä»¥ä¸Šæ­¥éª¤æ¶‰åŠå…ˆåºæ•°ç»„å’Œä¸­åºæ•°ç»„çš„åŒºé—´å¯¹åº”ï¼Œ è¿˜æœ‰å…ˆåºæ•°ç»„ç¡®å®šäº†æ ¹èŠ‚ç‚¹çš„å€¼éœ€è¦åœ¨ä¸­åºæ•°ç»„ä¸­æ‰¾åˆ°äº†å¯¹åº”çš„ä¸‹æ ‡ã€‚**
**ä¸Šé¢æˆ‘ä»¬æè¿‡å‡ºç°é‡å¤å€¼ç»“æ„ä¸å”¯ä¸€ï¼Œ è¿™æ˜¯å› ä¸ºå€¼ç›¸åŒä¸åŒçš„éå†æ–¹å¼è·å¾—çš„ä¸‹æ ‡ä¹Ÿå°±ä¸åŒã€‚**

###### **å”¯ä¸€æä¾›çš„è§£æ³•: å“ˆå¸Œè¡¨ + é€’å½’**
ç”±äºæ¯æ¬¡è¦æ ¹æ®å…ˆåºç¡®å®šæ ¹èŠ‚ç‚¹ç„¶åæŸ¥å…¶åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œ å¹²è„†ç›´æ¥æå“ˆå¸Œè¡¨ã€‚

ç®—æ³•æµç¨‹ï¼›
1. æ’é™¤ä¸æ»¡è¶³çš„æƒ…å†µï¼Œ æ¯”å¦‚æ•°ç»„ä¸ºnullï¼Œå…ˆåºæ•°ç»„å’Œä¸­åºæ•°ç»„é•¿åº¦ä¸ç­‰çš„æƒ…å†µã€‚ è¿™äº›ä¸€å®šä¸æ»¡è¶³ã€‚
2. ç”¨å“ˆå¸Œè¡¨å­˜å‚¨ä¸­åºæ•°ç»„ä¸­`key:æ•°ç»„å…ƒç´ ->value:ä¸‹æ ‡`çš„å…³ç³»ã€‚è°ƒç”¨è¾…åŠ©æ–¹æ³•`f`ã€‚
3. è¾…åŠ©æ–¹æ³•æ¥å—7ä¸ªå‚æ•°ï¼Œå„è‡ªæ•°ç»„åŠå…¶å·¦å³ä¸‹æ ‡è¾¹ç•Œå’Œå“ˆå¸Œè¡¨ã€‚å½“å…ˆåºæ•°ç»„çš„å·¦è¾¹ç•Œè¶Šè¿‡å³è¾¹ç•Œï¼Œ è¿”å›null; å½“å…ˆåºæ•°ç»„ä¸­åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹é‚£ä¹ˆç›´æ¥è¿”å›è¯¥èŠ‚ç‚¹;æ ¹æ®å…ˆåºæ•°ç»„ç¡®å®šæ ¹èŠ‚ç‚¹çš„å€¼æŸ¥æ‰¾å…¶åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œ è·å–ä¸‹æ ‡`k`ï¼Œ ç„¶åæ ¹æ®è¿™ä¸ªkæ¥è®¡ç®—å…ˆåºæ•°ç»„å’Œä¸­åºæ•°ç»„çš„å·¦åŒºé—´å’Œå³åŒºé—´ã€‚
4. æœ€åé€’å½’åœ°å·¦åŒºé—´éƒ¨åˆ†æˆä¸ºå½“å‰æ ¹èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œ é€’å½’åœ°å³åŒºé—´éƒ¨åˆ†æˆä¸ºå½“å‰æ ¹èŠ‚ç‚¹çš„å³å­©å­ã€‚

ç¡®å®šåŒºé—´çš„è¿‡ç¨‹ä¸åº”è¯¥æ˜¯éš¾ç‚¹: æ ¸å¿ƒç§˜è¯€æ˜¯å·¦å³åŒºé—´ä¸­åºæ•°ç»„å’Œå…ˆåºæ•°ç»„çš„é•¿åº¦ä¸€è‡´ï¼Œ è€Œä¸­åºæ•°ç»„çš„å·¦å³åŒºé—´å¾ˆå¥½ç¡®å®šã€‚`
`ä»£ç `:
```java
import java.util.HashMap;

// åˆ©ç”¨å…ˆåºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
// æµ‹è¯•é“¾æ¥ : https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
public class Coding009_PreorderInorderBuildBinaryTree {
    // ä¸æäº¤è¿™ä¸ªç±»
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int v) {
            val = v;
        }
    }
    //æäº¤è¿™ä¸ªç±»
    public class Solution {
        public TreeNode buildTree(int[] preorder, int[] inorder) {
            if(preorder == null || inorder == null || preorder.length != inorder.length){
                return null;
            }
            //key:ä¸­åºæ•°ç»„å…·ä½“çš„å…ƒç´ ï¼Œ valueï¼šä¸‹æ ‡
            HashMap<Integer, Integer> map = new HashMap<>();

            //éå†ä¸­åºæ•°ç»„å»ºç«‹å€¼->ä¸‹æ ‡çš„å…³ç³» ï¼ˆæ³¨æ„æ•°ç»„æ— é‡å¤å€¼æ‰èƒ½è¿™ä¹ˆå¹²ï¼‰
            for(int i=0;i<preorder.length;i++) {
                map.put(inorder[i],i);
            }
            //è°ƒç”¨è¾…åŠ©æ–¹æ³•ã€‚
            return f(preorder,0, preorder.length - 1, inorder,0, inorder.length-1, map);
        }

        public TreeNode f(int[] preorder, int preStart,int preEnd, int[] inorder, int inStart, int inEnd, HashMap<Integer, Integer> map){
                //å¤„ç†è¶Šç•Œæƒ…å†µ
                if(preStart > preEnd){
                    return null;
                }
                //æ„å»ºæ ¹èŠ‚ç‚¹
                TreeNode root = new TreeNode(preorder[preStart]);
                if(preStart == preEnd){
                    //å…ˆåºæ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ ç›´æ¥è¿”å›
                    return root;
                }
                //æ ¹æ®æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œ æŸ¥æ‰¾å…¶åœ¨ä¸­åºæ•°ç»„çš„ä¸‹æ ‡ä¸Š
                int k = map.get(preorder[preStart]);
                //ä¸­åºæ•°ç»„å·¦åŒºé—´éƒ¨åˆ†[inStart, k - 1] => é•¿åº¦ k - inStart. å…ˆåºèµ·å§‹ä¸ºpreStart + 1, ç»“å°¾éƒ¨åˆ†åŠ ä¸Šé•¿åº¦ - 1å³ preStart + k - inStart
                root.left = f(preorder, preStart + 1, preStart - inStart + k ,inorder, inStart, k - 1, map);
                //ä¸­åºæ•°ç»„å³åŒºé—´éƒ¨åˆ†[k+1, inEnd]. => é•¿åº¦ inEnd - k . å…ˆåºç»“å°¾ä¸ºpreEnd,å‡å»é•¿åº¦ + 1æ˜¯å…¶å³åŒºé—´çš„èµ·å§‹ preEnd - inEnd + k + 1
                root.right = f(preorder, preEnd - inEnd + k + 1, preEnd, inorder, k+1, inEnd, map);
                return root;
        }
    }
}

```

##### **017 å…ˆåºå’Œååºæ•°ç»„æ„é€ äºŒå‰æ ‘**

##### **018 ä¸­åºå’Œååºæ•°ç»„æ„é€ äºŒå‰æ ‘**

##### **019 éªŒè¯å®Œå…¨äºŒå‰æ ‘**

##### **020 æ™®é€šäºŒå‰æ ‘ä¸Šå¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ**
##### **021 æœç´¢äºŒå‰æ ‘ä¸Šå¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ**

##### **022 æ”¶é›†ç´¯åŠ å’Œä¸ºkçš„è·¯å¾„ï¼ˆé€’å½’å›æº¯å¤åŸï¼‰**
æœ¬é¢˜æ˜¯æ¶‰åŠé€’å½’è¿‡ç¨‹ä¸­çš„å¤åŸï¼Œ ä¿è¯å„ä¸ªé€’å½’åˆ†æ”¯å½¼æ­¤ç‹¬ç«‹ã€‚
![alt text](image-1.png)
>`Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22`
>`Output: [[5,4,11,2],[5,8,4,5]]`
>`Explanation: There are two paths whose sum equals targetSum:
>5 + 4 + 11 + 2 = 22
>5 + 8 + 4 + 5 = 22`

æœ¬é¢˜è¦æ±‚æ”¶é›†æ‰€æœ‰æ»¡è¶³targetçš„**å®Œæ•´è·¯å¾„**çš„é›†åˆã€‚
è·¯å¾„æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰ç»“ç‚¹ï¼Œ æ²¡æœ‰èµ°åˆ°å¶å­èŠ‚ç‚¹ä¸èƒ½ä¸‹ç»“è®ºï¼
å¦‚ä½•ç”¨ä¸€ä¸ªåˆ—è¡¨æ”¶é›†æ»¡è¶³è·¯å¾„çš„é›†åˆå‘¢ï¼Ÿ
è®¾è®¡ä¸€ä¸ªè·¯å¾„å’Œçš„å˜é‡ï¼Œ è¿˜æœ‰ä¸€ä¸ªè®°å½•å½“å‰è·¯å¾„èŠ‚ç‚¹çš„åˆ—è¡¨ã€‚
1. å½“é€’å½’å¾€ä¸‹èµ°çš„æ—¶å€™ï¼Œ å°†å½“å‰èŠ‚ç‚¹å€¼åŠ å…¥åˆ°åˆ—è¡¨ï¼Œ åŒæ—¶æ›´æ–°è·¯å¾„å’Œã€‚
2. å½“é€’å½’èµ°åˆ°å¶å­èŠ‚ç‚¹æ—¶åˆ¤æ–­æ•´ä¸ªè·¯å¾„å’Œæ˜¯å¦æ»¡è¶³ç›®æ ‡è·¯å¾„å’Œtargetï¼Œ æ»¡è¶³åˆ™å°†pathåˆ—è¡¨åŠ å…¥åˆ°ç»“æœçš„é›†åˆã€‚
3. ç”±äºè®¾è®¡é€’å½’èµ°åˆ°å¶å­èŠ‚ç‚¹æ—¶å°±åšæ­¥éª¤2çš„åˆ¤æ–­ï¼Œ æ‰€æœ‰åŸºçº¿æ¡ä»¶å°±æ˜¯å¶å­èŠ‚ç‚¹ï¼Œ ä¸ä¼šå‡ºç°èµ°åˆ°ç©ºä½ç½®çš„æƒ…å†µã€‚
4. é€’å½’å‘ä¸Šè¿”å›æ—¶ï¼Œ è¦æ¶ˆå»å‘ä¸‹è¿‡ç¨‹ä¸­çš„å½±å“ï¼Œ ä¿è¯å½“å‰èŠ‚ç‚¹åˆ°å„ä¸ªåˆ†å‰çš„æ˜¯ç‹¬ç«‹çš„ã€‚

`ä»£ç `
```java
import java.util.ArrayList;
import java.util.List;

// æ”¶é›†ç´¯åŠ å’Œç­‰äºaimçš„æ‰€æœ‰è·¯å¾„
// æµ‹è¯•é“¾æ¥ : https://leetcode.cn/problems/path-sum-ii/
// æäº¤å†…éƒ¨çš„Solutionç±»
public class Coding015_PathSumII {
    // ä¸æäº¤è¿™ä¸ªç±»
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int val){ this.val = val;}
    }

    /**
     * æ¯æ¬¡è°ƒç”¨fæ˜¯å¯¹äºpathæ˜¯ç‹¬ç«‹çš„ï¼Œ å³ä»¥è¯¥å¤„ä¸ºåˆ†æ”¯çš„ç»“æœäº’ä¸å½±å“ã€‚
     * é€’å½’å›æº¯å¤åŸ
     * @param cur å½“å‰æ‰€åœ¨çš„æ ‘èŠ‚ç‚¹
     * @param aim ç›®æ ‡å€¼
     * @param pathSum å½“å‰çš„è·¯å¾„å’Œ
     * @param path è·¯å¾„èŠ‚ç‚¹æ”¶é›†çš„è¡¨
     * @param ans ç­”æ¡ˆ
     */
    public static void f(TreeNode cur,int aim, int pathSum, List<Integer> path,List<List<Integer>> ans ){
        //å°†cur.valåŠ å…¥åˆ°è·¯å¾„ä¸­ã€‚
        path.add(cur.val);
        //å…ˆè®¨è®ºæ˜¯å¦ä¸ºå¶å­èŠ‚ç‚¹
        if(cur.left == null && cur.right == null){
            //å†åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦æ»¡è¶³ if true => æ·±æ‹·è´pathå¹¶åŠ å…¥åˆ°ansä¸­
            if(cur.val + pathSum == aim){
                //Javaæä¾›è¿­ä»£å™¨ç”Ÿæˆåˆ—è¡¨å®ç°äº†æ·±æ‹·è´
                //å…¶å®ƒè¯­è¨€å¯ä»¥å°è£…å‡½æ•°å®ç° C++è¿­ä»£å™¨éå†æ‹·è´ä¸€ä¸‹ ok.
                ans.add(new ArrayList<Integer>(path));
            }
        }
        else{
            //f=>å‰å¾€å·¦å­æ ‘åˆ†æ”¯
            if(cur.left != null){
                f(cur.left,aim,pathSum + cur.val,path,ans);
            }
            //f=>å‰å¾€å³å­æ ‘åˆ†æ”¯
            if(cur.right != null){
                f(cur.right,aim,pathSum + cur.val,path,ans);
            }
        }
        //å¤åŸ => ä¿è¯ç‹¬ç«‹æ€§
        path.removeLast();
    }

    /**
     * ä¸»æ–¹æ³•
     * @param root æ ‘çš„æ ¹èŠ‚ç‚¹
     * @param targetSum ç›®æ ‡è·¯å¾„å’Œ
     * @return è¿”å›æ»¡è¶³æ¡ä»¶çš„è·¯å¾„å’Œ
     */
    public static List<List<Integer>> pathSum(TreeNode root, int targetSum){
        var ans = new ArrayList<List<Integer>>();
        if(root != null){
            var path = new ArrayList<Integer>();
            f(root, targetSum, 0, path, ans);
        }
        return ans;
    }
}

```

##### **023 éªŒè¯å¹³è¡¡äºŒå‰æ ‘**
>é«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æ¯ä¸ªèŠ‚ç‚¹çš„ä¸¤ä¸ªå­æ ‘çš„æ·±åº¦ç›¸å·®ä¸è¶…è¿‡ä¸€çš„äºŒå‰æ ‘ã€‚
å¦‚æœä½ äº†è§£äº†AVLæ ‘çš„å®šä¹‰ï¼Œ è¿™é“é¢˜å¯¹å¹³è¡¡æ€§çš„å®šä¹‰ä¸AVLæ ‘ä¸€è‡´ã€‚

å®šä¹‰ï¼›
å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘ï¼Œ æ»¡è¶³å·¦å­æ ‘ä¸å³å­æ ‘çš„é«˜åº¦å·®â‰¤1.
å¹¶ä¸”å·¦å³å­æ ‘ä¹Ÿæ»¡è¶³è¿™ä¸ªæ€§è´¨ï¼Œ é‚£ä¹ˆè¿™é¢—æ ‘å°±æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚

æœ¬é¢˜ç›¸å½“äº => è®¾è®¡ä¸€ä¸ªç®—æ³•éªŒè¯äºŒå‰æ ‘æ˜¯AVLæ ‘

###### *`*è§£æ³•ä¸€:å®šä¹‰è§£å†³`**
è§£æ³•æ¶‰åŠä¸€ä¸ªæ±‚äºŒå‰æ ‘é«˜åº¦å‡½æ•°ï¼Œ å®ç°ä¸`011äºŒå‰æ ‘æœ€å¤§æ·±åº¦`ä¸€è‡´
```java
   //è§£æ³•ä¸€:æ ¹æ®å¹³è¡¡æ ‘çš„å®šä¹‰ï¼Œ è¿™é‡Œçš„å¹³è¡¡æ€§å®šä¹‰æ˜¯AVLæ ‘é£æ ¼
    //å€ŸåŠ©è¾…åŠ©æ–¹æ³•getHeightæ±‚é«˜åº¦ã€‚
    //æäº¤æ—¶ä¿®æ”¹å‡½æ•°å å’Œ é€’å½’æ–¹æ³•ä¸º-> isBalanced
    public boolean isBalanced1(TreeNode root) {
        if(root==null){
            return true;
        }

        //å…ˆåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ»¡è¶³å¹³è¡¡æ€§çš„å®šä¹‰
        if(Math.abs(getHeight(root.left)-getHeight(root.right))>1){
            return false;
        }else{
            //åˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦éƒ½å¹³è¡¡ã€‚
            return isBalanced1(root.left)&&isBalanced1(root.right);
        }
    }
    //Coding005_DepthOfBinaryTree ï¼› æ±‚é«˜åº¦ç®—æ³•ä¸æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦æ˜¯åŒä¸€ä¸ªã€‚
    private int getHeight(TreeNode root){
        return root==null?0:Math.max(getHeight(root.left),getHeight(root.right)) + 1;
    }
```

è§£æ³•ä¸€çš„å…·ä½“ç»†èŠ‚ä¼šåœ¨è§£æ³•ä¸‰åˆ†æ²»é»‘ç›’æ ‘å½¢dpï¼ˆå°è¯•ï¼‰æ³•è¯´æ˜ã€‚

###### **è§£æ³•äºŒ: å…¨å±€å˜é‡é€ƒè¯¾**
åœ¨è¿™ä¸ªç®€å•é¢˜å·ç®—æ³•ï¼Œ å›°éš¾é¢˜å·å¸¸æ•°æ—¶é—´çš„æ—¶ä»£ã€‚
æˆ‘ä¸ä¼šåŠ¨æ€è§„åˆ’çœŸçš„åšä¸åˆ°100%å‡»è´¥å—ï¼Ÿ

ä¸ºä»€ä¹ˆè§£æ³•ä¸€å¾ˆæ…¢ï¼Œ å› ä¸ºä¸€æ£µæ ‘è·‘äº†å¤šæ¬¡ï¼Œ è¿™æ ·å¯¼è‡´æ—¶é—´å¼€é”€å¤§ã€‚
å…¶å®å¯ä»¥è¿™æ ·æƒ³ï¼Œå½“åˆ¤æ–­ä¸å¹³è¡¡æ—¶å°±çŸ¥é“é€’å½’æ²¡å¿…è¦ç»§ç»­äº†ï¼Œæ˜¯å§ã€‚
å°è¯•å¼•å…¥ä¸€ä¸ªå…¨å±€å˜é‡`balance`, å½“å®ƒä¸ºfalseæ—¶è°ƒç”¨å‡½æ•°å¼€å§‹å°±ç›´æ¥è¿”å›ï¼› è¿™æ ·ä¿è¯å¦‚æœè¿™æ£µæ ‘æœ¬èº«å¹³è¡¡åªéœ€è¦è·‘ä¸€éå°±èƒ½ç¡®å®šï¼Œ ä¹Ÿä¸ä¼šé‡å¤è·‘ï¼Œ ä¸å¹³è¡¡å°±å…¨å±€å˜é‡æ ‡è®°ä¸ºfalseã€‚

ç”±æ­¤ï¼Œ æˆ‘ä»¬å†™å‡ºäº†æ–¹æ³•äºŒ
`ä»£ç `:
```java
  //------------------------------------è§£æ³•äºŒ---------------------------
    public static boolean balance = true;
    public static boolean isBalanced2(TreeNode root){
        balance = true;//å…ˆå‡è®¾æœ€åˆæ˜¯å¹³è¡¡çš„
        process(root);
        return balance;
    }
    //åœ¨è§£æ³•ä¸€ getHeightæ–¹æ³•çš„ç»†èŠ‚åŠ ä¸Šå¹³è¡¡æ€§balanceçš„æ£€éªŒ
    public static int process(TreeNode cur){
         if(!balance || cur == null){
             return 0;
         }
         
         int lh = process(cur.left);
         int rh = process(cur.right);
         
         if(Math.abs(lh - rh) > 1){
             balance = false;
             return 0;
         }
         else{
             return Math.max(lh, rh) + 1;
         }
    }
```

###### **è§£æ³•ä¸‰ï¼šåˆ†æ²»å’Œé»‘ç›’å°è£…æ€æƒ³(æ ‘å½¢dpçš„ç®€å•å°è¯•)**

å°è£…ä¸€ä¸ªç±»åŒæ—¶å¤„ç†æ”¶é›†å¤šç§ä¿¡æ¯ï¼Œ æ±‚é«˜åº¦å’Œåˆ¤æ–­å¹³è¡¡åŒæ—¶è¿›è¡Œã€‚
è§£æ³•ä¸€çš„åŠ£åŠ¿åœ¨äºå…ˆåˆ¤æ–­é«˜åº¦è¿™æ¡æ€§è´¨æ˜¯å¦æ»¡è¶³ï¼Œ åœ¨å»å·¦å³æ£€éªŒä¸¤ä¾§çš„å¹³è¡¡ã€‚ è¿™é‡Œå°†å¹³è¡¡æ€§å’Œé«˜åº¦åŒæ—¶å¤„ç†ï¼Œ é¥é¥é¢†å…ˆã€‚
æœ‰å…³äºæ ‘å½¢dpçš„ç»†èŠ‚ï¼Œ æ­£å¦‚æ ‡é¢˜æ‰€è¯´ï¼Œè¿™é‡Œä¸è°ˆï¼Œ åªæ˜¯ä¸ªæ ‡é¢˜ç½¢äº†ã€‚é‡ç‚¹æ˜¯é»‘ç›’å°è£…å¤„ç†ä¿¡æ¯çš„ä¾¿åˆ©æ€§
```java
   //----------------------è§£æ³•ä¸‰-----------------
    //å°è£…ä¸€ä¸ªç±»å¤„ç†å¤šç§ä¿¡æ¯
    public static class ReturnType{
        //é«˜åº¦
        public int height;
        //å¹³è¡¡
        public boolean isBalanced;
        public ReturnType(int h, boolean isB){
            height = h;
            isBalanced = isB;
        }
    }
    //æäº¤å‡½æ•°æ—¶ä¿®æ”¹æ–¹æ³•å => isBalanced
    public static boolean isBalanced3(TreeNode root){
        //ä¸»æ–¹æ³•è°ƒç”¨ => æ ¹èŠ‚ç‚¹çš„å¹³è¡¡æ€§å­—æ®µ
        return process2(root).isBalanced;
    }
    //processæ–¹æ³•åŠŸèƒ½: è¿”å›å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘çš„å¹³è¡¡ä¿¡æ¯æ”¶é›†ã€‚
    public static ReturnType process2(TreeNode cur){
        //å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œ é»˜è®¤æ­¤æ—¶é«˜åº¦ä¸º0 ï¼Œä¸”å¹³è¡¡ï¼
        if(cur == null){
            return new ReturnType(0,true);
        }
        
        //åˆ†è€Œæ²»ä¹‹ï¼Œ é€’å½’åœ°å¤„ç†å·¦å³å­æ ‘ï¼Œ è¿”å›ä¸¤è€…çš„ä¿¡æ¯
        ReturnType left = process2(cur.left);
        ReturnType right = process2(cur.right);
        
        //æ ¹æ®å®šä¹‰: å·¦å­æ ‘å¹³è¡¡ï¼Œ å³å­æ ‘å¹³è¡¡ï¼Œ ä¸”å·¦å³é«˜åº¦å·®å°äºç­‰äº1
        // => å¯¼å‡ºå½“å‰èŠ‚ç‚¹çš„å¹³è¡¡æ€§ã€‚ ç›´æ¥ç”±å­—æ®µè·å¾—
        boolean isBalanced = left.isBalanced && right.isBalanced
                && Math.abs(left.height - right.height) < 2;
        //è¿”å›ç”±curèŠ‚ç‚¹çš„ä¿¡æ¯:é«˜åº¦ï¼Œå¹³è¡¡æ€§ => å‘ä¸Šè°ƒç”¨
        return new ReturnType(Math.max(left.height , right.height) + 1, isBalanced);
    }
```


##### 
:::
